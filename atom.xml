<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://zixfy.github.io</id>
    <title>zixfy&apos;s blog</title>
    <updated>2023-11-03T08:12:43.564Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://zixfy.github.io"/>
    <link rel="self" href="http://zixfy.github.io/atom.xml"/>
    <subtitle>Life is to live it</subtitle>
    <logo>http://zixfy.github.io/images/avatar.png</logo>
    <icon>http://zixfy.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, zixfy&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[在Python中使用Type Hints和Mypy]]></title>
        <id>http://zixfy.github.io/post/zai-python-zhong-shi-yong-type-hints-he-mypy/</id>
        <link href="http://zixfy.github.io/post/zai-python-zhong-shi-yong-type-hints-he-mypy/">
        </link>
        <updated>2023-10-29T14:21:13.000Z</updated>
        <content type="html"><![CDATA[<p>原文：<a href="https://zhuanlan.zhihu.com/p/662747187">https://zhuanlan.zhihu.com/p/662747187</a></p>
<p>[TOC]</p>
<p><strong>Reference:</strong></p>
<p><a href="https://peps.python.org/pep-0484/">PEP 484</a></p>
<p><code>Python</code>是动态类型的解释型语言，所以有时类型不匹配的问题要拖到运行期才能被发现（比如对一个<code>int</code>对象取下标）</p>
<p>还有就是如果没有类型信息，代码里<code>naming</code>又很烂的话，就很难猜出来鼠标指着的那个对象是啥类型，之前帮老师弄一个<code>Python</code>项目就因为这个问题很打脑阔</p>
<h3 id="0-basic">0-Basic</h3>
<p>为了解决这些问题，我们可以使用<code>Python3.5+</code>标准库引入的类型提示（<code>Type Hints</code>）和辅助用的<code>typing</code>模块</p>
<p><code>Py3.5+</code>可以为变量<code>instance</code>、函数<code>function</code>（方法<code>method</code>）、类<code>class</code>、模块<code>module</code>提供类型提示</p>
<p>但类型提示只是一种注释，或者说元信息，解释器把类型信息存储到了<code>function</code>或<code>class type</code>的<code>__annotation__</code>属性中</p>
<p>在运行期，解释器也并不会对变量的类型断言</p>
<p>类型进行也没有静态检查的要求，需要一个<code>IDE</code>帮助我们根据<code>Hint</code>进行类型推导，比如<code>PyCharm</code>的<code>Type Introspection</code>，还会在推导出矛盾时给出一个<code>warning</code></p>
<p>或者使用<code>mypy</code>等<code>static typing checker</code>，会解析代码找出类型错误</p>
<p><code>Type Hint</code>的好处总结是</p>
<p>类型推导自动获取调用函数的签名、返回值类型，提高可读性与开发效率</p>
<p>让运行期潜在的类型安全问题提前暴露</p>
<h4 id="type-hint">Type Hint</h4>
<p>最基本的语法是使用标注赋值（<code>Annotated assignment statements</code>），表达式语法为<code>&lt;var&gt; : &lt;type hint&gt; [= &lt;expr&gt;] </code>，其中<code>type hint</code>大多情况下是一个<code>type</code>或者类型名的字符串</p>
<pre><code>alpha: int = 0
# or
bravo: &quot;str&quot; = 2.3
# PyCharm: Expected type 'str', got 'float' instead
</code></pre>
<p>（<code>PyCharm</code>中按住<code>Ctrl</code>指向变量名可以看推导的类型）</p>
<p>但这个语法补丁在一些场合不适用，比如元组解构</p>
<pre><code class="language-python">charlie: int, delta: float = (114, 5.14)       
</code></pre>
<p>根据标注赋值表达式语法</p>
<pre><code class="language-python">annotated_assignment_stmt ::=  augtarget &quot;:&quot; expression
                               [&quot;=&quot; (starred_expression | yield_expression)]
</code></pre>
<p>单纯是因为左手侧只能单变量，不支持解构</p>
<p>此时可以改写成下方丑陋的形式</p>
<pre><code class="language-python">charlie: int
delta: float
charlie: int, delta: float = (114, 5.14)   
</code></pre>
<p>但要注意，只给出<code>type hint</code> ，而不赋值变量，则不会把这个变量名加入到<code>globals</code>或<code>locals</code>，也就是说直接使用会抛出<code>Undefined NameError</code>，举栗说</p>
<pre><code class="language-python">alpha: int 
bravo: &quot;str&quot; = &quot;i hate cowards&quot;
def main():
    charlie: int = 114
    delta: float
    print(locals()) # {'charlie': 114}
    print(globals()['bravo']) # i hate cowards

    # print(delta) 
    # -&gt; UnboundLocalError: cannot access local variable 'delta' where it is not associated with a value
    # print(globals()['alpha']) -&gt; KeyError: 'alpha'
    # print(alpha) -&gt; NameError: name 'alpha' is not defined

main()
</code></pre>
<p>这里在<code>main</code>函数作用域中，<code>delta</code>未被加入<code>locals()</code>中不能使用，在全局作用域下，<code>aplha</code>没有加入到<code>globals()</code>中不能使用</p>
<p>或者我们在元组解构时，直接标注整个元组也行</p>
<pre><code class="language-python">someTup: tuple[int, float] = (114, 5.14)
echo, foxtrot = someTup
# PyCharm: Variable &quot;echo&quot; Inferred type: int
# PyCharm: Variable &quot;foxtrot&quot; Inferred type: float
</code></pre>
<p>为函数标注时，也是用<code>:</code> + 类型标注形参，并且在函数体之前使用<code>-&gt;</code>尾置类型来标注返回值</p>
<pre><code class="language-python">def stoi(s: str, base: int = 10) -&gt; int:
    return int(s, base=base)
thatNumber = stoi(&quot;107&quot;)
# PyCharm: Variable &quot;thatNumber&quot; Inferred type: int
</code></pre>
<h4 id="type-alias">Type Alias</h4>
<p>首先要知道在<code>Python</code>中一切皆对象，类型如<code>int, str, list</code>以及自定义类都是一个<code>type</code>类型的对象（<code>(list.__class__ is type) is True</code>，<code>type</code>对象重载了<code>__call__</code>，也就是<code>()</code>，所以能通过<code>type</code>对象调用对应类型的构造函数）</p>
<pre><code class="language-python">print(object.__class__ is type)
# True
print(type.__class__ is type)
# True
print(type(type(type(type(type)))))
# &lt;class 'type'&gt;
</code></pre>
<p>当然<code>type</code>也是一个对象，而且<code>object</code>和<code>type</code>的类型都是<code>type</code></p>
<pre><code class="language-python">import numpy as np
dummy = np.zeros((3, 3), dtype=np.int32)
def up_cast(arr: np.ndarray) -&gt; np.ndarray:
    t: type = get_type_from_config(opt=[np.single, np.half, np.double])
    return arr.astype(t)
print(up_cast(dummy))
</code></pre>
<p>所以也把一个对象标注成<code>type</code>也没问题</p>
<p><strong>typing.TypeAliasType</strong></p>
<p>在<code>Py3.12</code>中为<code>type hint</code>引入了类型别名的语法<code>type &lt;alias&gt; = &lt;expr&gt;</code></p>
<pre><code class="language-python">type String = str
s1: String = 'Let life be beautiful like summer flowers'
Str = str
s2: Str = 'and death like autumn leaves.'
print(String.__class__, String)
# &lt;class 'typing.TypeAliasType'&gt; String
print(Str.__class__, Str)
# &lt;class 'type'&gt; &lt;class 'str'&gt;

# print(String()) -&gt; TypeError: 'typing.TypeAliasType' object is not callable
print(Str())
</code></pre>
<p>从样例可以看出，可以从一个类型创建出新类型，但新类型的类型不是<code>type</code>，而是<code>typing.TypeAliasType</code></p>
<p>所以无法直接从类型别名创建出新对象，但是使用一个对象引用原类型创建别名时，还可以用别名创建对象</p>
<p>为了这个语法，<code>type</code>变成了一个上下文关键字<code>soft keyword</code>，但我觉得为什么要和内置的<code>type</code>冲突呢，把这个关键字改成<code>alias</code>不合适嘛..</p>
<p><strong>typing.NewType</strong></p>
<p>另外一种从现有类型创建新类型的方法是<code>typing.NewType</code>，对于<code>Type Hint</code>而言，<code>NewType</code>被当作原始类型的子类，也就是不同的类型，这在语义上类似<code>Go</code>的<code>type</code>别名，不同类型使用相同的数据结构</p>
<p>然而运行时使用<code>NewType</code>从原始类型构造对象时，它只是返回实参，所以运行时对象还是原始类型</p>
<pre><code class="language-python">Verse = typing.NewType('Verse', str)


def say(some: Verse) -&gt; None:
    print(some)


say(Verse('The world has kissed my soul with its pain,'
          ' asking for its return in songs.'))
# say('It is the tears of the earth that keep here smiles in bloom.')
# PyCharm: Expected type 'Verse', got 'str' instead

print(Verse.__class__)
# &lt;class 'typing.NewType'&gt;
print(isinstance(Verse, str))
# False
print(Verse('').__class__)
# &lt;class 'str'&gt;

# print(Verse([1, 2]))
# PyCharm: Expected type 'str', got 'list[int]' instead
</code></pre>
<p>从样例可以看出，在静态类型推导中，<code>Verse</code>和<code>str</code>是不同类型。但在运行时，通过<code>Verse()</code>转化的<code>str</code>其实还是<code>str</code>对象啦</p>
<h3 id="1-mypy">1-mypy</h3>
<p>在继续之前，让我们先装备一个<code>Python</code>静态类型检查器，<code>mypy</code></p>
<p>运行<code>mypy</code>会分析代码，并且出现类型推导矛盾或属性/方法错误时，<code>mypy</code>程序直接报错</p>
<p>但与<code>PyCharm inspection</code>一样，不要求所有代码都带有类型标注，所以不妨在代码重灾区加入<code>Type Hint</code>并使用<code>mypy</code>罢</p>
<p>首先打开终端输入<code>pip3 install mypy</code>安装<code>mypy</code></p>
<p>之后把它集成到<code>PyCharm IDE</code>中，点击<code>File -&gt; Settings -&gt; Tools -&gt; External Tools</code></p>
<p>新建一个<code>Tool</code>，<code>Program: mypy</code>，设定项目目录和源代码目录，这样在<code>IDE</code>中右键<code>-&gt; External Tools -&gt; mypy</code>就可以运行<code>mypy</code>检查了</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/zixfy/imageshack2023/main/img/cbd1b438feafae788bdf77fb2a71a2d.png" alt="" loading="lazy"></figure>
<p>当然也可以每次<code>Debug</code>前运行一下<code>mypy</code>，打开入口脚本的<code>Run Configuration</code>，添加一个<code>Before launch -&gt; Run External Tools</code>，启用<code>mypy</code></p>
<p><code>mypy</code>现在（<code>1.6.1</code>）的问题是，<code>Py3.12</code>更新的<code>Type Hint</code>特性还没支持</p>
<h3 id="2-utilities">2-Utilities</h3>
<p><code>typing</code>提供了一些通用的标注类型用于<code>Type Hint</code>和类型推导</p>
<h4 id="final">Final</h4>
<p><code>typing.Final (Py3.8+)</code>标注一个对象为<strong>只读</strong>，语义上类似<code>C#</code>的<code>readonly</code>，<code>C/C++</code>的<code>const</code></p>
<pre><code class="language-python">from typing import Final
MAX_SIZE: Final = 9000
MAX_SIZE += 1  

class Connection:
    TIMEOUT: Final[int] = 10
class FastConnector(Connection):
    TIMEOUT = 1  # Error reported by type checker

# mypy:
# main.py:78: error: Cannot assign to final name &quot;MAX_SIZE&quot;  [misc]
# main.py:86: error: Cannot assign to final name &quot;TIMEOUT&quot;  [misc]
</code></pre>
<p>以官方文档为例，被标注为<code>Final</code>的对象不能重新赋值，同时作为类属性的<code>Final</code>对象不能在子类中被重写(<code>overwrite</code>)</p>
<h4 id="any">Any</h4>
<p>在类型推导中，被标注为<code>typing.Any</code>的对象为动态类型</p>
<p>可以被任何类型，同样<strong>也可以</strong>赋值给任何类型</p>
<p>语义上类似<code>C++/Rust</code>的<code>std::any</code>、<code>Go</code>的<code>interface{}</code></p>
<p>注意<code>Any</code>和<code>object</code>在类型推到中的区别</p>
<pre><code class="language-python">def get_x(o: Any) -&gt; int:
    return o.x
# mypy： okay

def get_x(o: object) -&gt; int:
    return o.x
# main.py:79: error: &quot;object&quot; has no attribute &quot;x&quot;  [attr-defined]
</code></pre>
<p><code>Any</code>是开放的，类型推导认为<code>Any</code>类型可以有任意属性/方法，而<code>object</code>是封闭的，使用<code>object</code>类没有的属性会使<code>mypy</code>报错</p>
<p><code>Any</code>举例：反射</p>
<pre><code class="language-python">from typing import Any

class Some:
    def __init__(self):
        self.tick = 0

def touch(o: Any) -&gt; Any:
    if hasattr(o, 'tick'):
       	o.tick = o.tick + 1
    return o


y = Some()
print(touch(y).tick)
# 1
print(touch('nothing'))
# nothing
</code></pre>
<h4 id="union">Union</h4>
<p>将对象标注为<code>T1 | T2 | ... | TN</code>（<code>Py3.10</code>之前没有语法糖要使用<code>typing.Union[T1, T2, ... TN]</code>）表示一种 和类型（相对于作为<code>class</code>的积类型，<code>class</code>内部是多个类型的组合），意味着在运行时对象的类型是<code>T1, T2, ... TN</code>其中之一，用处是实现非继承的多态</p>
<p>语义上类似<code>C# SumType</code>， <code>C++ std::variant</code>，<code>Rust Enumerated types</code></p>
<p>以我之前写的代码为例</p>
<pre><code class="language-python">import numpy as np
def forward(self, images_data: np.ndarray) -&gt; list[np.ndarray] | np.ndarray:
    # ...
    result: list[np.ndarray] = self._forward(dispatched_jobs)

    for i in range(len(result)):
        result[i] = result[i][:real_batch_size, ...]
    if len(result) == 1:
        return result[0]
    return result
# mypy： okay
</code></pre>
<p>这里<code>forward</code>返回模型推理结果的类型是运行时确定的（读取的模型结构可能是多流输出或单流输出），因此使用<code>Union</code>标注返回值</p>
<h4 id="optional">Optional</h4>
<p><code>typing.Optional[T]</code>表示类型<code>T</code>的可空版本，当然<code>Python</code>对象可空，所以<code>Optional[T]</code>就是<code>T | None</code></p>
<p>语义上类似<code>C# Nullable&lt;T&gt;</code>， <code>C++ std::optional</code>，<code>Rust std::option</code></p>
<p>一般来说，不使用<code>T</code>的某个特殊值而是可空类型表示空值，因为可读性好而且可能没有适合的特殊值表示空值</p>
<pre><code class="language-python">from typing import Optional

class Node:
    # ... 
    
def dfs(root: Optional[Node]) -&gt; None:
    if root is None:
        return
    dfs(root.left)
    print(root.val, end=', ')
    dfs(root.right)
</code></pre>
<p>比如在深度优先搜索中把形参标注为可空类型</p>
<h4 id="self">Self</h4>
<p>在类中标注方法，如果涉及到了当前类类型，比如这样</p>
<pre><code class="language-python">class Some:
    def clone(self) -&gt; Some:
        return self._clone_impl()
</code></pre>
<p>那么解释器会认为在<code>Some</code>类内部<code>Some</code>还没有完成定义，所以使用了<code>Some</code>时解释器不认可代码，这像是一个缺陷似的</p>
<pre><code class="language-python">class Some:
    def clone(self) -&gt; 'Some':
        return self._clone_impl()
</code></pre>
<p>此时可以改为用字符串标注，类型推导/类型检查器也可以接受</p>
<pre><code class="language-python">class Tensor:
    def __add__(self, other: Self) -&gt; Self:
        # ...

    def __sub__(self, other: Self) -&gt; Self:
        # ...

    def __mul__(self, other: Self) -&gt; Self:
        # ...

</code></pre>
<p>在<code>Py3.11</code>，可以使用<code>typing.Self</code>标注当前类类型了，一般常用于运算符重载</p>
<p>要注意，<code>Self</code>其实是一个泛型的语法糖（<code>typing.TypeVar</code>）</p>
<p>所以子类<code>overrite</code>父类方法时，<code>Self</code>推导为子类类型，而不是父类类型</p>
<h3 id="3-introspection">3-Introspection</h3>
<p>对于类型标注，解释器会将变量名和标注存储在<code>function</code>/<code>class</code>/<code>module</code>对象的<code>__annotations__</code>属性里</p>
<p>但函数作用域内的局部变量的标注不会被存储在<code>function</code>对象的<code>__annotations__</code>里</p>
<pre><code class="language-python">from typing import get_type_hints

class Some:
    a: int
    b: tuple[str, int]

    def __init__(self):
        self.c: int = 0
        self.d: float = 1.

    def f(self, x: int, y: str) -&gt; float:
        tmp: list[int] = [1, 1, 4]
        return .0


glob: str = 'module var'
print(get_type_hints(Some))
# {'a': &lt;class 'int'&gt;, 'b': tuple[str, int]}
print(get_type_hints(Some().f))
# {'x': &lt;class 'int'&gt;, 'y': &lt;class 'str'&gt;, 'return': &lt;class 'float'&gt;}
print(globals()['__annotations__'])
# {'glob': &lt;class 'str'&gt;}
</code></pre>
<p>而且最好使用<code>typing.get_type_hints</code>在运行时获取<code>Type Hints</code>，因为它帮我们处理了不同的对象</p>
<p>现在我们获得了内省类型标注的能力，也许可以用它来做运行时类型断言，但我认为更应该提高<code>Py</code>代码内标注覆盖率来做静态断言</p>
<p>所以我认为<code>get_type_hints</code>更大的用处是为<code>Python</code>元编程提供基础设施（如本文第<code>6</code>部分的<code>dataclass</code>）</p>
<h3 id="4-functionmethod">4-Function/Method</h3>
<h4 id="never">Never</h4>
<p>在<code>Python</code>中，函数正常执行流<code>return</code>或无<code>return</code>语句，返回的是<code>None</code></p>
<p>但是标注一个永不正常返回的函数，应该使用<code>typing.Never</code>，而不是<code>None</code></p>
<pre><code class="language-python">from typing import Never

class CmdExit(Exception): pass

def stop_thread() -&gt; Never:
    raise CmdExit()
</code></pre>
<p>（在<code>Py3.11</code>之前，需要换用<code>typing.NoReturn</code>）</p>
<h4 id="callable">Callable</h4>
<p>我们可以用<code>typing.Callable</code>来标注<code>Python</code>函数、方法或其他函数对象（重载了<code>__call__</code>的对象）</p>
<p><code>Callable</code>可以是一个泛型（见下文第<code>5</code>部分），其中<code>Callable[[Arg1, Arg2, ... ArgN], RetT]</code>标注一个形参类型为<code>Arg1, Arg2, ... ArgN</code>，返回值类型为<code>RetT</code>的函数对象</p>
<pre><code class="language-python">def async_query(on_success: Callable[[int], None],
                on_error: Callable[[int, Exception], None]) -&gt; None:
    ...  # Body
</code></pre>
<p>一个官方文档的例子</p>
<p>当然，除了回调，我们在实现函数装饰器时，形参也是<code>Callable</code></p>
<pre><code class="language-python">def using_huawei_api(func: Callable) -&gt; Callable:
    def wrapper(*args, **kwargs):
        init_huawei_api()
        res = func(*args, **kwargs)
        finalize_huawei_api()
        return res
    return wrapper


@using_huawei_api
def runner(img_paths: list[str], model_cfg: CfgNode) -&gt; Err:
    # ...

what_type = runner
# PyCharm : Variable &quot;what_type&quot; Inferred type:
# (...) -&gt; Any
</code></pre>
<p>当然我们实现装饰器时往往需要处理的是任意的函数对象，比如我的代码里<code>@using_huawei_api</code>在任意函数调用前后做了一些事</p>
<p>但是像这样把原函数标注成非泛型的<code>Callable</code>时，装饰器返回的闭包会丢失类型标注</p>
<p>这里被装饰的<code>runner</code>被<code>PyCharm</code>推导为<code>(...) -&gt; Any</code>，也就是<code>Callable[..., Any]</code>，一个形参变长，返回任意类型的函数</p>
<p>这肯定不好，会破坏我们的后续的类型推导</p>
<pre><code class="language-python">from typing import ParamSpec, TypeVar
Param = ParamSpec('Param')
T = TypeVar('T')
</code></pre>
<p>所以可以使用<code>typing</code>提供的辅助泛型<code>ParamSpec</code>表示形参类型，同时把返回值类型也标注为泛型</p>
<pre><code class="language-python">def using_huawei_api(func: Callable[Param, T]) -&gt; Callable[Param, T]:
    def wrapper(*args: Param.args, **kwargs: Param.kwargs) -&gt; T:
        # ...
    return wrapper

@using_huawei_api
def runner(img_paths: list[str], model_cfg: CfgNode) -&gt; Err:
    # ...

what_type = runner
# PyCharm: Variable &quot;what_type&quot; Inferred type:
# (img_paths: list[str], model_cfg: CfgNode) -&gt; Err
</code></pre>
<p>使用<code>ParamSpec.args</code>解构出<code>arguments</code>（<code>*args</code>），<code>ParamSpec.kwargs</code>解构出<code>keyword arguments</code>（<code>**kwargs</code>），然后将标注转发给闭包就可以，此时<code>PyCharm</code>也正确推导出了被装饰函数的签名/返回类型</p>
<h4 id="decorators">Decorators</h4>
<p>关于函数/方法，<code>typing</code>还提供了几个装饰器</p>
<p>其中和<code>OOP</code>相关的是<code>typing.override</code>/<code>typing.final</code></p>
<pre><code class="language-python">class Base:
    def log_status(self) -&gt; None:
        ...

class Sub(Base):
    @override
    def log_status(self) -&gt; None:  # Okay: overrides Base.log_status
        ...

    @override
    def done(self) -&gt; None:  # Error reported by type checker
        ...
</code></pre>
<p>以官方文档为例，使用<code>override</code>装饰方法时，是提示类型检查器我们在使用继承多态，父类中必须存在同名的相同签名的方法</p>
<pre><code class="language-python">class Base:
    @final
    def done(self) -&gt; None:
        ...
class Sub(Base):
    def done(self) -&gt; None:  # Error reported by type checker
        ...

@final
class Leaf:
    ...
class Other(Leaf):  # Error reported by type checker
    ...
</code></pre>
<p>相对地，就像其他语言中的<code>OOP</code>，<code>typing.final</code>可以装饰一个类或方法，表示类不能被继承或方法不能被<code>override</code></p>
<p>另外，如果我们的函数需要重载（当然肯定不是<code>C++</code>中的重载概念，这里指的就是函数多态），可以用<code>typing.overload</code>装饰不同的重载版本</p>
<pre><code class="language-python">def get_vec(dim1: int, dim2: int | None, dim3: int | None) -&gt; list[int] | list[list[int]] | list[list[list[int]]]:
    if dim3 is not None:
        return [[[0 for i in range(dim3)] for j in range(dim2)] for k in range(dim1)]
    if dim2 is not None:
        return [[0 for j in range(dim2)] for k in range(dim1)]
    return [0 for k in range(dim1)]
</code></pre>
<p>比如这个<code>get_vec</code>函数根据形参长度返回不同类型的对象，如果只是像这样把返回值标注成<code>Union</code>，那无论用户如何调用<code>get_vec</code>，得到的推导类型都是<code>list[int] | list[list[int]] | list[list[list[int]]]</code>，那就没啥意义了，不同入参方式对应不同返回值，这时我们利用<code>overload</code>表达这种语义</p>
<pre><code class="language-python">@overload
def get_vec(dim1: int) -&gt; list[int]:
    ...
@overload
def get_vec(dim1: int, dim2: int) -&gt; list[list[int]]:
    ...
@overload
def get_vec(dim1: int, dim2: int, dim3: int) -&gt; list[list[list[int]]]:
    ...
def get_vec(dim1, dim2=None, dim3=None):
    # ... implementation 


v1 = get_vec(1)
v2 = get_vec(1, 4)
v3 = get_vec(5, 1, 4)

# PyCharm:
# Variable &quot;v1&quot; Inferred type: list[int]
# Variable &quot;v2&quot; Inferred type: list[list[int]]
# Variable &quot;v3&quot; Inferred type: list[list[list[int]]]
</code></pre>
<p>使用<code>overload</code>需要像这样写，使用<code>@overload</code>装饰每一个重载版本，函数体使用<code>...</code>忽略，而且<code>overload</code>重载声明后要紧接实现的函数，这里<code>@overload</code>重载中已经进行了标注，有了类型推导的信息，所以具体实现函数中不用标注了</p>
<p>根据入参，<code>PyCharm</code>也正确推导出了不同的返回值类型</p>
<h3 id="5-generic">5-Generic</h3>
<p>这里泛型指的是<code>Type Hint</code>里的泛型，<code>Python</code>运行时没有泛型可言</p>
<p><code>Type Hint</code>中泛型参数包含在方括号（<code>[]</code>）中</p>
<h4 id="builtin-container">Builtin Container</h4>
<p><code>Type Hint</code>中<code>Py</code>内置容器不仅有非泛型版本，也有泛型版本</p>
<p><code>list[T]/set[T]</code>标注存储类型<code>T</code>的列表/集合</p>
<p><code>tuple[T1, T2, T3, ..., TN]</code>标注存储类型<code>T1, T2, T3, ..., TN</code>的元组</p>
<p><code>dict[K, V]</code>标注键类型<code>K</code>，值类型<code>V</code>的字典</p>
<p>当然，<code>Py3.9</code>以下要换用<code>typing.List</code>,<code>typing.Set</code>,<code>typing.Tuple</code>,<code>typing.Dict</code>,因为当时还没有为这些类型对象重载<code>[]</code></p>
<h4 id="protocol">Protocol</h4>
<p><code>typing.Protocol</code>定义一种鸭子类型（也就是非继承的接口）,具体是定义一个空壳类，继承自<code>Protocol</code>，然后定义鸭子类型需要满足的方法</p>
<pre><code class="language-python">class CanSub(Protocol):
    def __sub__(self, other: Self) -&gt; Self:
        pass
</code></pre>
<p>像这里我们定义一种可减的类型<code>CanSub</code></p>
<pre><code class="language-python">def zero(x: CanSub) -&gt; CanSub:
    return x - x
zero(1)
zero([1, 0, 7])

# mypy: error: Argument 1 to &quot;zero&quot; has incompatible type &quot;list[int]&quot;; expected &quot;CanSub&quot;  [arg-type]
</code></pre>
<p>然后被标注为<code>CanSub</code>的对象必须重载<code>-</code>才可以</p>
<p>通常一个具体类型可以满足多个鸭子类型，所以现在考虑如何组合不同的<code>Protocol</code></p>
<pre><code class="language-python">@runtime_checkable
class CanAdd(Protocol):
    def __add__(self, other: Self) -&gt; Self:
        pass
    
@runtime_checkable
class CanAddSub(CanAdd, CanSub, Protocol):
    pass

print(isinstance([], CanAddSub))
# False
print(isinstance([], CanAdd))
# True
print(isinstance(1, CanAddSub))
# True
</code></pre>
<p>现在再写一个可加类型<code>CanAdd</code>，组合<code>CanAdd</code>和<code>CanSub</code>的方式是再定义一个<code>CanAddSub</code>同时继承自``CanAdd/CanSub/Protocol<code>（</code>Protocol`需要<strong>最后</strong>被继承）</p>
<p>然后用<code>typing.runtime_checkable</code>装饰一下鸭子类型，就可以在运行时用<code>isinstance</code>判断对象是否满足相应<code>Protocol</code></p>
<h4 id="typevar">TypeVar</h4>
<p>通过<code>typing.TypeVar</code>定义一个泛型</p>
<pre><code class="language-python">T = TypeVar('T')  # Can be anything
S = TypeVar('S', bound=str)  # Can be any subtype of str
A = TypeVar('A', str, bytes)  # Must be exactly str or bytes
</code></pre>
<p>默认的<code>TypeVar</code>是开放类型，但可以通过<code>bound</code>或<code>*constrains</code>参数施加简单的泛型约束</p>
<pre><code class="language-python">T = TypeVar('T')
def slow_sort(arr: list[T]) -&gt; list[T]:
    if len(arr) &lt;= 1:
        return arr
    base: T = arr[len(arr) // 2]
    left: list[T] = [x for x in arr if x &lt; base]
    middle: list[T] = [x for x in arr if x == base]
    right: list[T] = [x for x in arr if x &gt; base]
    return slow_sort(left) + middle + slow_sort(right)

what_type = slow_sort(['a', 'c', 'b'])
# PyCharm: Variable &quot;what_type&quot; Inferred type: list[str]
</code></pre>
<p>创建一个泛型函数的例子，在<code>Py3.12</code>中，不用再定义<code>TypeVar</code>了，直接用<code>def slow_sort[T](arr: list[T]) -&gt; list[T]</code>就可以定义泛型函数，但<code>mypy</code>好像还没支持这个特性</p>
<pre><code class="language-python">U = TypeVar('U')
V = TypeVar('V')
class pair(Generic[U, V]):
    def __init__(self, u: U, v: V):
        self.first = u
        self.second = v


p = pair(107, 'zixfy')
a, b = p.first, p.second
# PyCharm: Variable &quot;a&quot; Inferred type: int
#          Variable &quot;v&quot; Inferred type: str
</code></pre>
<p>而让类继承<code>typing.Generic</code>可以创建泛型类，同样地，在<code>Py3.12</code>中可以使用<code>class pair[U, V]:</code>定义泛型类</p>
<h4 id="typevartuple">TypeVarTuple</h4>
<p>（<code>mypy1.6.1</code>对<code>TypeVarTuple</code>的支持还是实验特性，需要在<code>mypy</code>程序参数中加入<code>--enable-incomplete-feature=TypeVarTuple --enable-incomplete-feature=Unpack</code>）</p>
<p>变长泛型，也就是一个打包了若干类型的列表(<code>TypeList</code>)</p>
<p>通过<code>typing.Unpack</code>，我们可以把这些类型从<code>TypeVarTuple</code>中解构出来</p>
<p>考虑实现如下的类似<code>C++ std::apply</code>的功能，输入函数<code>f</code>和实参<code>*args</code>，在<code>apply</code>内部调用原函数<code>f</code></p>
<p>这要求<code>f</code>形参类型和<code>*args</code>类型一致，所以样例中将形参和<code>*args</code>都标注为<code>Unpack[Ts]</code>（变长的泛型）</p>
<pre><code class="language-python">from typing import Callable, TypeVarTuple, Unpack
T = TypeVar('T')
Ts = TypeVarTuple('Ts') 

def apply(f: Callable[[Unpack[Ts]], T], *args: Unpack[Ts]) -&gt; T:
    return f(*args)

def f(x: int, y: float, prefix: str) -&gt; str:
    return prefix + str(x + y)

# g = apply(f, 1.333, 1.333, &quot;Result: &quot;)
# mypy: Argument 1 to &quot;apply&quot; has incompatible type 
# &quot;Callable[[int, float, str], str]&quot;; 
# expected &quot;Callable[[float, float, str], str]&quot;


g = apply(f, 1, 1.333, &quot;Result: &quot;)
print(g)
</code></pre>
<p>这样，在调用<code>apply</code>，若实参类型不符，<code>mypy</code>会帮我们找出类型错误</p>
<p>如果不都标注为<code>Unpack[Ts]</code>，而是标注为<code>...</code>，则无法检查实参，因为<code>...</code>表示任意的变长泛型，而且如果同时把原函数形参和<code>*args</code>都标注为<code>...</code>，<code>mypy</code>不认可</p>
<p>同时可以看到，我们可以利用<code>TypeVarTuple</code>标注<code>Py</code>函数的变长参数（<code>*args</code>）了</p>
<h4 id="typeddict">TypedDict</h4>
<p>在<code>Py</code>中，函数不仅可以有变长参数<code>*args</code>，还可以有关键字参数<code>**kwargs</code>,<code>kwargs</code>在运行时就是一个<code>dict</code></p>
<p>相应地，<code>Py3.11</code>引入了<code>typing.TypedDict</code>，限制<code>dict</code>指定键需要对应特定类型</p>
<p>结合<code>Unpack</code>，我们就可以标注<code>kwargs</code>了喔</p>
<pre><code class="language-python">from typing import Unpack, TypedDict, NotRequired

class Opt(TypedDict):
    lower: int
    upper: int
    as_type: NotRequired[type]
</code></pre>
<p>首先定义一个空类<code>Opt</code>标注关键字参数的名字和类型，如果某个参数不是必须的，则将对应类型<code>T</code>标注为<code>typing.NotRequired[T]</code>版本</p>
<pre><code class="language-python">def clip(x: int, **kwargs: Unpack[Opt]):
    r: int = max(min(x, kwargs['upper']), kwargs['lower'])
    print(kwargs.__class__)
    if 'as_type' in kwargs:
        return kwargs['as_type'](r)
    return r


g = clip(-1, lower=107, upper=109, as_type=str)
print(g, type(g))
# 107 &lt;class 'str'&gt;

# h = clip(1, lower=1 )
# mypy: Missing named argument &quot;upper&quot; for &quot;clip&quot;  [call-arg]

# l = clip(114, lower=514, upper=1919.810)
# mypy: Argument &quot;upper&quot; to &quot;clip&quot; has incompatible type &quot;float&quot;; expected &quot;int&quot;  [arg-type]

</code></pre>
<p>在函数签名内，使用<code>Unpack[Opt]</code>解构<code>TypedDict</code>标注<code>**kwargs</code>，可以看到<code>mypy</code>已经可以找出<code>kwargs</code>中的类型错误了</p>
<h4 id="contravariantcovariant">Contravariant/Covariant</h4>
<p>协变（<code>covariant</code>）和逆变（<code>contravariant</code>）是泛型（<code>TypeVar</code>）的两个关键字参数</p>
<p>其实这个有些像<code>C#</code>里的<code>in</code>和<code>out</code>关键字..</p>
<p>假设某个<code>TypeVar</code>被推导为具体类型<code>T</code>，如果<code>TypeVar</code>是协变的，那么也可以被看作<code>T</code>的某个子类型（更加严格的类型）</p>
<p>反之如果<code>TypeVar</code>是逆变的，那么也可以被看作<code>T</code>的某个父类型（更加宽松的类型）</p>
<p>我们往往把某个接口方法返回值定义成协变的，因为接口的实现类里往往信息更多，可以生成更详细的子类型</p>
<p>同样，也可以把某个接口方法形参定义成逆变的，因为接口的实现类往往信息更多，可以处理更不详细的父类型</p>
<p>还是举个栗子吧</p>
<pre><code class="language-python">class Item(object): pass
class Bread(Item): pass
class Freedom(Item): pass


Out = TypeVar('Out', covariant=True)
In = TypeVar('In', contravariant=True)


class Factory(Generic[In, Out]):
    @abc.abstractmethod
    def get(self) -&gt; Out:
        pass

    @abc.abstractmethod
    def consume(self, x: In) -&gt; None:
        pass
</code></pre>
<p>这里我们定义了协变与逆变泛型分别为<code>Out</code>与<code>In</code></p>
<p>然后写了数据类<code>Item/Bread/Freedom</code>，其中<code>Item</code>是父类</p>
<p>最后定义了一个泛型接口<code>Factory[In, Out]</code>，其<code>get</code>返回值<code>Out</code>是协变的，而<code>consume</code>形参<code>In</code>是逆变的</p>
<pre><code class="language-python">class Dream(Factory[Item, Item]):
    @override
    def get(self) -&gt; Freedom:
        return Freedom()

    @override
    def consume(self, x: Item) -&gt; None:
        print(f&quot;Dream eats {type(x).__name__}, &quot;)
</code></pre>
<p>在<code>Factory[Item, Item]</code>的实现类<code>Dream</code>中，我们将<code>get</code>的返回值类型<code>overrite</code>成<code>Freedom</code>，这是可以的，因为接口里这里是协变，而<code>Freedom</code>又是<code>Item</code>的子类；但将<code>Freedom</code>替换成<code>Item</code>的父类<code>object</code>就是不可取的</p>
<pre><code class="language-python">class Work(Factory[Item, Item]):
    @override
    def get(self) -&gt; Bread:
        return Bread()

    @override
    def consume(self, x: object) -&gt; None:
        print(f&quot;Work burns {&quot;anything&quot; if type(x) is object else type(x).__name__}, &quot;)
</code></pre>
<p>而在<code>Factory[Item, Item]</code>的另一个实现类<code>Work</code>中，我们将<code>consume</code>的形参类型<code>overrite</code>成<code>object</code>，这是可以的，因为接口里这里是逆变，而<code>object</code>又是<code>Item</code>的父类</p>
<p>但将<code>object</code>替换成<code>Item</code>的子类<code>Bread</code>时，<code>mypy</code>会报错<code>This violates the Liskov substitution principle</code>，里氏原则里有说<strong>任何基类可以出现的地方，子类一定可以出现</strong>，但这里父子关系是反过来的，可能这就是为什么叫做逆变吧..</p>
<pre><code class="language-python">Dream().consume(Bread())
Work().consume(Dream().get())
Work().consume(object())
# Dream eats Bread, 
# Work burns Freedom,
# Work burns anything,
# mypy: okay

# Dream().consume(object())
# mypy: no
</code></pre>
<p>btw, <code>type</code>，或者说<code>typing.Type</code>的泛型版本<code>type[C]</code>也是协变的</p>
<h3 id="6-dataclass">6-dataclass</h3>
<p><code>dataclass</code>是<code>Py</code>中的结构体，它也是通过类型标注定义的</p>
<pre><code class="language-python">from dataclasses import dataclass

@dataclass
class PersonImageInformation(object):
    image_name: str
    person_id: int
    image_quality: float
</code></pre>
<p>这里用,<code>@dataclass</code>装饰<code>PersonImageInformation</code>后</p>
<p><code>PersonImageInformation</code>会被添加和定义的类属性相对应的构造方法、哈希、重载<code>&lt;</code>, <code>&gt;</code>, <code>==</code>, <code>str()</code>等</p>
<pre><code class="language-python">info = PersonImageInformation(
    image_name='/some/path',
    image_quality=0.92,
    person_id=107)

# info2 = PersonImageInformation(
#    image_name='/some/path',
#    person_id=107)
# mypy: Missing positional argument &quot;image_quality&quot; in call to &quot;PersonImageInformation&quot;  [call-arg]

# info3 = PersonImageInformation(
#     image_name=0,
#     image_quality=0.92,
#     person_id=107)
# mypy: Argument &quot;image_name&quot; to &quot;PersonImageInformation&quot; has incompatible type &quot;int&quot;; expected &quot;str&quot;  [arg-type]
</code></pre>
<p>可以看到生成的构造函数也是带类型标注的，实际上就是通过内省<code>__annotation__</code>属性拿到的，但<code>dataclass</code>用的不是<code>typing</code>模块，而是<code>inspect</code>模块</p>
<pre><code class="language-python">cls_annotations = inspect.get_annotations(cls)	
</code></pre>
<p>在添加构造方法<code>__init__</code>时，类型标注也被写进方法的签名里</p>
<pre><code class="language-python">def _init_param(f):
    # Return the __init__ parameter string for this field.  For
    # example, the equivalent of 'x:int=3' (except instead of 'int',
    # reference a variable set to int, and instead of '3', reference a
    # variable set to 3).
    # ...
</code></pre>
<p>有些库也是像这样利用<code>Type Hints</code>进行元编程的，比如<code>pydantic</code></p>
<p>以上</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++泛型之柯里化、函数组合]]></title>
        <id>http://zixfy.github.io/post/cfan-xing-zhi-ke-li-hua-han-shu-zu-he/</id>
        <link href="http://zixfy.github.io/post/cfan-xing-zhi-ke-li-hua-han-shu-zu-he/">
        </link>
        <updated>2023-10-29T14:20:28.000Z</updated>
        <content type="html"><![CDATA[<p>原文：<a href="https://zhuanlan.zhihu.com/p/662698843">https://zhuanlan.zhihu.com/p/662698843</a></p>
<p><strong>Reference:</strong></p>
<p><a href="https://sighingnow.github.io/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp_currying_partial_application.html">C++ 实现 Currying 和 Partial application</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/47315860">从零开始的简单函数式C++（八）函数组合 - 知乎 (zhihu.com)</a></p>
<p>抛开柯里化和函数组合在非函数式的<code>C++</code>语言中能有多大用与抽象的额外开销不谈.. 本文只是单纯地解析一下如何利用<code>C++</code>泛型（模板）实现这两个高阶函数</p>
<p>一个最小实现其实不是很复杂，只要先了解一点变长模板、<code>forwarding reference</code>、<code>lambda</code>就可以..</p>
<h3 id="compose">Compose</h3>
<p>首先是函数组合（<code>Compose</code>）</p>
<p>给定函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>f</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>f</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">f_1, f_2, \dots, f_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，我们希望给定输入<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><msub><mi>a</mi><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">a_1, a_2, \dots a_M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，总有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>e</mi><mo>(</mo><msub><mi>f</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>f</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>f</mi><mi>N</mi></msub><mo>)</mo><mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>…</mo><msub><mi>a</mi><mi>M</mi></msub><mo>)</mo><mo>=</mo><msub><mi>f</mi><mi>N</mi></msub><mo>(</mo><msub><mi>f</mi><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>…</mo><mo>(</mo><msub><mi>f</mi><mn>2</mn></msub><mo>(</mo><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>…</mo><msub><mi>a</mi><mi>M</mi></msub><mo>)</mo><mo>)</mo><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">Compose(f_1, f_2, \dots, f_N)(a_1  \dots a_M) = f_N(f_{N-1}\dots (f_2(f_1(a_1  \dots a_M))))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p>
<p>也就是$Compose(f_1, f_2, \dots, f_N)  \equiv f_N(f_{N-1}\dots (f_2(f_1))) $</p>
<p>由于$Compose(f_2, \dots, f_{N})  \equiv f_{N}(f_{N-1}\dots (f_2)) $</p>
<p>所以$Compose(f_1, f_2, \dots, f_N) \equiv a_1  \dots a_M \rightarrow Compose(f_2, \dots, f_{N})(f1(a_1  \dots a_M)) $</p>
<p>那可以看出，我们实现<code>Compose</code>的一种方式是写一个递归模板函数，但这样引入了递归的开销</p>
<p>另外考虑如果令<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><mi>f</mi><mo>=</mo><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">a\ |\ f = f(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span>，那么</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>e</mi><mo>(</mo><msub><mi>f</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>f</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>f</mi><mi>N</mi></msub><mo>)</mo><mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>…</mo><msub><mi>a</mi><mi>M</mi></msub><mo>)</mo><mo>=</mo><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>…</mo><msub><mi>a</mi><mi>M</mi></msub><mo>)</mo><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><msub><mi>f</mi><mn>2</mn></msub><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><mo>…</mo><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><msub><mi>f</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">Compose(f_1, f_2, \dots, f_N)(a_1 \dots a_M) =    f_1(a_1\dots a_M) \ |\ f_2 \ |\ \dots\ |\ f_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>因为<code>C++14</code>中引入了折叠表达式，我们也可以通过<code>operator</code>重载 + 折叠表达式的方式实现这种非递归的链式调用与函数组合</p>
<h4 id="0-递归实现">0. 递归实现</h4>
<p>先来看简单一点的递归版本实现</p>
<pre><code class="language-C++">template &lt;typename... Func&gt; struct Compose {
private:
    using FuncChain = std::tuple&lt;Func...&gt;;
    FuncChain funcs;
public:
  template &lt;typename... FuncRef&gt;
  explicit Compose(FuncRef &amp;&amp;...);

  template &lt;typename... ArgT&gt; 
  decltype(auto) operator()(ArgT &amp;&amp;...);
}
</code></pre>
<p>我们把<code>Compose</code>实现为模板函数对象，模板参数为<code>Func...</code>，是需要组合的函数的<strong>值</strong>类型列表</p>
<p>在<code>Compose</code>内部，我们维护了一个<code>tuple&lt;Func...&gt;</code>，存储所有待组合的函数，因为调用组合函数时，它需要看到所有被组合的函数，所以我们才将<code>Compose</code>实现为能持有状态的函数对象</p>
<p><code>Compose</code>的构造函数是<code>template &lt;typename... FuncRef&gt; Compose(FuncRef &amp;&amp;...)</code>，使用<code>Forwarding Refence</code>（万能引用）区分<code>FuncRef&amp;&amp;</code>是<code>Func</code>的左值引用还是右值引用，从而支持复制/移动语义</p>
<p>的这里不直接写成<code>Compose(Func &amp;&amp;...)</code>的原因是，编译器在生成<code>Compose</code>构造函数代码时，已经进入了<code>Compose</code>内，<code>Func...</code>类型已确定，<code>Func&amp;&amp;</code>不是万能引用，而是一个确定的类型</p>
<p>简单地说，万能引用的原理是引用折叠，当<code>FuncRef = T</code>或<code>FuncRef = T&amp;&amp;</code>时，<code>FunRef&amp;&amp; = T&amp;&amp;</code></p>
<p>当<code>FuncRef = T&amp;</code>时，<code>FunRef&amp;&amp; = T&amp;</code>，了解了这些规则，就能理解这里为何还要套一层模板</p>
<p>最后是<code>operator()</code>这里返回类型声明为<code>decltype(auto)</code></p>
<p><code>decltype(auto)</code>对于编译器而言大概就是这个意思</p>
<pre><code class="language-c++">decltype(auto) f() {
    return some_expr;
}
// ==
decltype((some_expr)) f() {
    return some_expr;
}
</code></pre>
<p>也就是保持返回的表达式的引用类型和<code>cv</code>限定符，避免<code>Compose</code>修改了原始函数们的返回值类型</p>
<pre><code class="language-c++">template &lt;typename... FuncRef&gt;
explicit Compose(FuncRef &amp;&amp;...f) : funcs{std::forward&lt;FuncRef&gt;(f)...} {};
</code></pre>
<p>递归版本的话，<code>operator()</code>内部调用一个递归模板<code>_invoke</code>，令<code>_invoke&lt;Index, ArgT...&gt;</code>调用第<code>Index</code>个函数，然后把结果传给第<code>Index + 1</code>个函数<code>_invoke&lt;Index + 1, ArgT...&gt;</code></p>
<pre><code class="language-c++">template &lt;std::size_t Index, typename... ArgT&gt;
decltype(auto) _invoke(FuncChain &amp;funcs, ArgT &amp;&amp;...args) {
  if constexpr (Index + 1 == sizeof...(Func))
    return std::get&lt;Index&gt;(funcs)(std::forward&lt;ArgT&gt;(args)...);
  else   
    return _invoke&lt;Index + 1&gt;(funcs)(std::get&lt;Index&gt;(funcs)(std::forward&lt;ArgT&gt;(args)...)); 
} 

template &lt;typename... ArgT&gt; decltype(auto) operator()(ArgT &amp;&amp;...args) {
  return _invoke&lt;0, ArgT...&gt;(funcs, std::forward&lt;ArgT&gt;(args)...);
}
</code></pre>
<p>如果当前是最后一个函数（<code>Index + 1 == sizeof...(Func)</code>），那么直接返回结果，否则递归调用</p>
<p>这样就完成了，但还有个小问题，我们现在的实现处理不了这种情况：中间某个函数返回了<code>void</code>，比如</p>
<pre><code class="language-c++">string s{&quot;nihao&quot;};
auto get_ref_to_my_name = [&amp;]() -&gt; string &amp; { return s; };
auto then_modify_it = [](string &amp;sref) -&gt; void {
  sref = &quot;goodbye&quot;;
};
auto and_print = [&amp;]() -&gt; void {
  cout &lt;&lt; &quot;s == \&quot;&quot; &lt;&lt; s &lt;&lt; &quot;\&quot; now\n&quot;;
};
auto &amp;&amp;action1 = Compose(get_ref_to_my_name, then_modify_it, and_print);
action1();
</code></pre>
<p>因为<code>C/C++</code>中<code>void</code>比较特殊，如果有<code>void f(), void g()</code>，那么<code>f(g())</code>是不符表达式语法的，组合<code>f</code>和<code>g</code>应该用<code>f(), g()</code></p>
<p>所以这里我们对<code>void</code>特判一下</p>
<pre><code class="language-c++">decltype(auto) _invoke(FuncChain &amp;funcs, ArgT &amp;&amp;...args) {
  // ...
  using CurrentResT = std::invoke_result_t&lt;
      std::remove_reference_t&lt;decltype(std::get&lt;Index&gt;(funcs))&gt;, ArgT...&gt;;
  if constexpr (!std::is_void_v&lt;CurrentResT&gt;)
    return _invoke&lt;Index + 1, CurrentResT&gt;(
        funcs, std::get&lt;Index&gt;(funcs)(std::forward&lt;ArgT&gt;(args)...));
  else {
    std::get&lt;Index&gt;(funcs)(std::forward&lt;ArgT&gt;(args)...);
    return _invoke&lt;Index + 1&gt;(funcs);
  }
} 
</code></pre>
<p>其中使用<code>std::invoke_result_t</code>让编译器告诉我们当前第<code>Index</code>个函数的返回值类型，如果是<code>void</code>，就避免把<code>void</code>传递到下一个函数</p>
<p>最后我们的<code>Compose</code>是一个模板类，所以写一个模板参数引导</p>
<pre><code class="language-c++">template &lt;typename... FuncRef&gt;
Compose(FuncRef...) -&gt; Compose&lt;std::remove_reference_t&lt;FuncRef&gt;...&gt;;
</code></pre>
<p>这里的引导的作用是帮助编译器<code>Compose</code>通过构造函数的形参类型推导出模板参数类型，我们构造函数输入是万能引用，存储的<code>Func</code>是值类型，所以用<code>std::remove_reference_t</code>擦除引用</p>
<pre><code class="language-c++">auto &amp;&amp;action1 = Compose(get_ref_to_my_name, then_modify_it, and_print);
</code></pre>
<p>这样<code>Compose</code>就不用写模板参数了</p>
<p>那现在我们把它改成非递归版本的XD</p>
<h4 id="1-非递归实现">1. 非递归实现</h4>
<p>上文提到过的</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><mi>f</mi><mo>=</mo><mi>f</mi><mo>(</mo><mi>a</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">a\ |\ f = f(a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>e</mi><mo>(</mo><msub><mi>f</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>f</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>f</mi><mi>N</mi></msub><mo>)</mo><mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>…</mo><msub><mi>a</mi><mi>M</mi></msub><mo>)</mo><mo>=</mo><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>…</mo><msub><mi>a</mi><mi>M</mi></msub><mo>)</mo><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><msub><mi>f</mi><mn>2</mn></msub><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><mo>…</mo><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><msub><mi>f</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">Compose(f_1, f_2, \dots, f_N)(a_1 \dots a_M) =    f_1(a_1\dots a_M) \ |\ f_2 \ |\ \dots\ |\ f_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>在表达能力不弱的<code>C++</code>中也能实现，我们这里选择管道符<code>|</code>重载函数调用关系，当然其他二元<code>operator</code>比如逗号也可以，<code>|</code>的话好看一点，以及<code>Unix</code>管道与<code>C++ 20 ranges</code>都是使用<code>|</code>表示组合关系的</p>
<p>首先实现<code>operator|</code>的重载，同时为了处理<code>void</code>，我们引入一个辅助的空类型<code>None</code></p>
<pre><code class="language-c++">struct None {};
template &lt;typename Arg, typename Func&gt;
decltype(auto) operator|(Arg &amp;&amp;a, Func f) {
  using Ret = std::invoke_result_t&lt;Func, decltype(a)&gt;;
  if constexpr (std::is_void_v&lt;Ret&gt;) {
    f(a);
    return None{};
  } else
    return f(a);
}
template &lt;typename Func&gt; decltype(auto) operator|(None, Func f) {
  using Ret = std::invoke_result_t&lt;Func&gt;;
  if constexpr (std::is_void_v&lt;Ret&gt;) {
    f();
    return None{};
  } else
    return f();
}
</code></pre>
<p>首先<code>a | f</code>返回<code>f(a)</code>，但如果返回<code>void</code>的话就转而返回一个<code>None{}</code></p>
<p>然后我们再为<code>None</code>重载一个<code>operator|</code>（第一个形参是<code>None</code>不是泛型，重载优先级更高），避免<code>None{}</code>被传入当前函数</p>
<p>测试一下</p>
<pre><code class="language-c++">auto add = [](auto a, auto b) { return a + b; };
auto multiply = [](auto x) { return x * 2; };
auto square = [](auto x) { return x * x; };
cout &lt;&lt; (add(3, 6) | multiply | square) &lt;&lt; endl;
// 324
</code></pre>
<p>现在只剩实现<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi>o</mi><mi>s</mi><mi>e</mi><mo>(</mo><msub><mi>f</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>f</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>f</mi><mi>N</mi></msub><mo>)</mo><mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>…</mo><msub><mi>a</mi><mi>M</mi></msub><mo>)</mo><mo>=</mo><msub><mi>f</mi><mn>1</mn></msub><mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>…</mo><msub><mi>a</mi><mi>M</mi></msub><mo>)</mo><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><msub><mi>f</mi><mn>2</mn></msub><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><mo>…</mo><mtext> </mtext><mi mathvariant="normal">∣</mi><mtext> </mtext><msub><mi>f</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">Compose(f_1, f_2, \dots, f_N)(a_1 \dots a_M) =    f_1(a_1\dots a_M) \ |\ f_2 \ |\ \dots\ |\ f_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord">∣</span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>了</p>
<p>我们可以用<code>C++ 14</code>折叠表达式，简单说，如果有边长模板参数<code>...F =  F2, F3 ... FN</code>，那么<code>(result_of_F1 | ... | F)</code>等价于<code>(((result_of_F1 | F2) | F3)... | FN)</code>，这样结合重载的<code>|</code>就实现函数组合了</p>
<pre><code class="language-c++">template &lt;typename ...Func&gt; struct Compose {
private:
  // ...
  template &lt;std::size_t... Indexes, typename... ArgT&gt;
  decltype(auto) _invoke(FuncChain &amp;funcs,
                         std::integer_sequence&lt;std::size_t, Indexes...&gt;,
                         ArgT &amp;&amp;...args) {
    return (std::get&lt;0&gt;(funcs)(std::forward&lt;ArgT&gt;(args)...) | ... |
            std::get&lt;Indexes + 1&gt;(funcs));
  };

public:
  // ...
  template &lt;typename... ArgT&gt; decltype(auto) operator()(ArgT &amp;&amp;...args) {
    return _invoke(funcs, std::make_index_sequence&lt;sizeof...(Func) - 1&gt;{},
                   std::forward&lt;ArgT&gt;(args)...);
  }
};
</code></pre>
<p>这里<code>operator()</code>向<code>_invoke</code>传递了一个<code>std::make_index_sequence&lt;sizeof...(Func) - 1&gt;</code>，也就是<code>std::integer_sequence&lt;std::size_t, 0, 1, 2, sizeof...(Func) - 2&gt;</code>，这样<code>_invoke</code>内部就能解构出这些下标，有了下标我们就能索引第<code>1</code>（从<code>0</code>计数）个函数到最后一个函数了</p>
<p>在<code>_invoke</code>内，我们首先用<code>std::get&lt;0&gt;(funcs)(std::forward&lt;ArgT&gt;(args)...) </code>拿到第<code>0</code>个函数返回值，然后用折叠表达式展开<code>operator()</code>传入的下标，链式调用后续函数</p>
<p>测试代码</p>
<pre><code class="language-c++">using namespace std;
int main() {
  auto add = [](auto a, auto b) { return a + b; };
  auto multiply = [](auto x) { return x * 2; };
  auto square = [](auto x) { return x * x; };
  cout &lt;&lt; (add(3, 6) | multiply | square) &lt;&lt; endl;
  cout &lt;&lt; Compose(add, multiply, square) (3, 6)&lt;&lt; endl;
  // Case0: Normal func chain, output 324 324

  string s{&quot;nihao&quot;};
  auto get_ref_to_my_name = [&amp;]() -&gt; string &amp; { return s; };
  auto then_modify_it = [](string &amp;sref) -&gt; void {
    sref = &quot;goodbye&quot;;
  };
  auto and_print = [&amp;]() -&gt; void {
    cout &lt;&lt; &quot;s == \&quot;&quot; &lt;&lt; s &lt;&lt; &quot;\&quot; now\n&quot;;
  };
  auto &amp;&amp;action1 = Compose(get_ref_to_my_name, then_modify_it, and_print);
  action1();
  // Case1: compose contains void on functional chain; output:s == &quot;goodbye&quot; now

  auto &amp;&amp;meaningless = Compose([] {});
  meaningless();
  // Case2: single compose 

  auto f1 = [](int a, int b) { return a + b; };
  auto f2 = [](int x) -&gt; double { return x * 1.16666666666666; };
  auto &amp;&amp;action2 = Compose(
      Compose(f1, f2), [](auto x) { return &quot;Result: &quot; + std::to_string(x); });
  cout &lt;&lt; action2(-3, 5);
  // Case3: Nested compose
  // output:
  // Result: 2.333333
}
</code></pre>
<p>包含<code>4</code>种情况：普通组合、中间有<code>void</code>的组合、单个函数组合、嵌套组合</p>
<p><strong>Full code:</strong> [<a href="https://github.com/zixfy/cpp-algorithm/blob/main/functional/compose.hpp">Github</a>]</p>
<h3 id="currying">Currying</h3>
<p>接下来顺便写一个柯里化（<code>Currying</code>），这里涉及到了函数形参类型的解构，所以我们主要利用<code>std::function</code>类实现柯里化</p>
<p><em>柯里化（Currying）是一种将多参数函数转换为一系列单参数函数的技术</em></p>
<p>对于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>元函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>N</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">f(x_1, x_2, \dots, x_N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>， 令<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>y</mi><mo>(</mo><mi>f</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">Curry(f)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">)</span></span></span></span>为柯里化后的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span></p>
<p>那么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>y</mi><mo>(</mo><mi>f</mi><mo>)</mo><mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>)</mo><mo>(</mo><msub><mi>a</mi><mn>2</mn></msub><mo>)</mo><mo>…</mo><mo>(</mo><msub><mi>a</mi><mi>N</mi></msub><mo>)</mo><mo>=</mo><mi>f</mi><mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>a</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><msub><mi>a</mi><mi>N</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">Curry(f)(a_1)(a_2)\dots (a_N) = f(a_1, a_2, \dots a_N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>令<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>=</mo><mi>a</mi><mo>→</mo><mi>f</mi><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><msub><mi>x</mi><mi>N</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">g = a \rightarrow f(x_1 = a_1, x_2, \dots x_N )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>由于$Curry(g(a_1))(a_2)(a_3)\dots(a_N) = g(a_1)(a_1, a_2, \dots a_N) $</p>
<p>两式结合也就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>y</mi><mo>(</mo><mi>f</mi><mo>)</mo><mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>)</mo><mo>(</mo><msub><mi>a</mi><mn>2</mn></msub><mo>)</mo><mo>…</mo><mo>(</mo><msub><mi>a</mi><mi>N</mi></msub><mo>)</mo><mo>=</mo><mi>C</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>y</mi><mo>(</mo><mi>g</mi><mo>(</mo><msub><mi>a</mi><mn>1</mn></msub><mo>)</mo><mo>)</mo><mo>(</mo><msub><mi>a</mi><mn>2</mn></msub><mo>)</mo><mo>(</mo><msub><mi>a</mi><mn>3</mn></msub><mo>)</mo><mo>…</mo><mo>(</mo><msub><mi>a</mi><mi>N</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">Curry(f)(a_1)(a_2)\dots (a_N) = Curry(g(a_1))(a_2)(a_3)\dots(a_N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>y</mi><mo>(</mo><mi>f</mi><mo>)</mo><mo>=</mo><mi>a</mi><mo>→</mo><mi>C</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>y</mi><mo>(</mo><mi>g</mi><mo>)</mo><mo>=</mo><mi>a</mi><mo>→</mo><mi>C</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>y</mi><mo>(</mo><mi>f</mi><mo>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>=</mo><mi>a</mi><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>N</mi></msub><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">Curry(f) = a \rightarrow Curry(g) = a \rightarrow Curry(f(x_1 = a, x_2, \dots ,x_N))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p>
<p>所以我们将<code>Curry</code>实现为一个递归闭包</p>
<pre><code class="language-c++">template &lt;typename RetT, typename... ArgsT&gt;
auto Curry(std::function&lt;RetT(ArgsT...)&gt; func) {
  if constexpr (sizeof...(ArgsT) &lt; 2)
    return func;
  else
    return _curry_combine&lt;RetT, ArgsT...&gt;(std::move(func));
};
</code></pre>
<p>创建一个模板函数<code>Curry</code>解构出<code>std::function</code>的返回值类型<code>RetT</code>和形参类型<code>...ArgsT</code></p>
<p><code>Curry</code>接收原始<code>std::function</code>，输出柯里化后的闭包，或原始函数的形参数量少于<code>2</code>，那就直接返回原函数，这里使用使用<code>if constexpr</code>条件编译</p>
<pre><code class="language-c++">template &lt;typename Return, typename Arg, typename... Args&gt;
auto _curry_combine(std::function&lt;Return(Arg, Args...)&gt; original) {
   // f(x_1, x_2, ... x_N)
  if constexpr (sizeof...(Args) == 0)
    return original;
  else
    return [f = std::move(original)](Arg &amp;&amp;arg) { // arg -&gt; curry(f(arg, x_2, x_3, ..., x_N))
      return _curry_combine(//curry(f(x_1 = arg, x_2, x_3, ..., x_N))
          std::function([&amp;f, &amp;arg](Args &amp;&amp;...args) {
       		 return f(std::forward&lt;Arg&gt;(arg), std::forward&lt;Args&gt;(args)...);
              // f((x_1 = arg, x_2, x_3, ..., x_N)
      }));
    };
}
</code></pre>
<p><code>_curry_combine</code>用于生成递归闭包，每一层闭包存储当前的形参<code>arg</code>与上一层闭包的引用<code>f</code>即可</p>
<p>最后我们处理的都是<code>std::function</code>，但<code>std::function</code>能从<code>C++</code>函数或函数指针或函数对象构造</p>
<pre><code class="language-c++">template &lt;typename FuncLike&gt;
auto Curry(FuncLike&amp;&amp; func) {
  return Curry(std::function{std::forward&lt;FuncLike&gt;(func)});
};
</code></pre>
<p>所以再重载一个<code>Curry</code>支持其他的可调用对象，构造相应的<code>function</code></p>
<p>测试代码</p>
<pre><code class="language-c++">auto f(int a, int b, int c, int d, int e, int f) {
  return a + b + c + d + e + f;
}
auto f2(int&amp; ref, int val) { ref = val; }
int main() {
  auto cf1 = Curry(f);
  std::cout &lt;&lt; cf1(1)(1)(4)(5)(1)(4)&lt;&lt; std::endl;
  // Case0: normal
  // 16
  int what;
  auto cf2 = Curry(f2);
  auto &amp;&amp;setter = cf2(what);
  setter(107);
  std::cout &lt;&lt; what &lt;&lt; std::endl;
  //Case1: Delay Invoke
  //107
    
  auto cf3 = Curry([] (std::string const &amp;a, std::string const &amp; b) {return a + b;});
  std::cout &lt;&lt; cf3(std::string{&quot;hola&quot;})(std::string{&quot; amigo&quot;}) &lt;&lt; std::endl;
  // Case2: lambda
  // hola amigo
}
</code></pre>
<p>以上函数组合与柯里化的完整实现代码：[<a href="https://github.com/zixfy/cpp-algorithm/blob/main/functional/compose.hpp">compose.hpp</a>, <a href="https://github.com/zixfy/cpp-algorithm/blob/main/functional/curry.hpp">curry.hpp</a>]</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++实现简易RPC]]></title>
        <id>http://zixfy.github.io/post/cshi-xian-jian-yi-rpc/</id>
        <link href="http://zixfy.github.io/post/cshi-xian-jian-yi-rpc/">
        </link>
        <updated>2023-10-29T14:19:09.000Z</updated>
        <content type="html"><![CDATA[<p>原文：<a href="https://zhuanlan.zhihu.com/p/662574190">https://zhuanlan.zhihu.com/p/662574190</a></p>
<p>好久没有在知乎写随笔捏.. 因为这些天在玩Octopath Traveler和学习<a href="https://pdos.csail.mit.edu/6.824/schedule.html"><code>MIT 6.5840</code></a>课程的说</p>
<p>在<code>MIT 6.5840</code>课程<code>lab</code>中构建分布式系统时，节点之间的通信都是通过远程过程调用（<code>Remote Procedure call</code>）实现的，简单地说就是，<code>RPC</code>客户端请求远程服务端执行指定函数，并将计算结果通过网络传回</p>
<p>无论是<code>lab1</code>使用的<code>Go</code>语言标准库的<code>net/rpc/</code>还是之后<code>lab</code>中课程组模拟的带<code>RPC</code>功能的网络，<code>RPC</code>的大概流程都是</p>
<ol>
<li>客户端将实参对象序列化到字节，发送到服务端</li>
<li>服务端要根据客户端请求正确路由到指定函数，当然函数名可以放到<code>RPC</code>传输所依赖的网络协议里，比如<code>HTTP</code>或自己定义的。在我的实现里，我是利用<code>HTTP</code>协议完成<code>RPC</code>的，直接把函数名放在<code>HTTP url</code>里了.. 然后在服务端写了个<code>url</code>拦截</li>
<li>服务端反序列化得到形参对象，把返回值对象序列化到字节回复客户端，客户端再反序列化</li>
</ol>
<p>更多关于<code>RPC</code>的详情，这篇带图的<a href="https://xiaolincoding.com/network/2_http/http_rpc.html">文章</a>讲的很清楚！</p>
<p>综上，为了能在<code>C++</code>实现<code>RPC</code>的方法（不用其他第三方库，除了<code>fmt</code>因为我写时用的<code>C++ 17</code>所以没有<code>std::format</code>），我们得写这几部分代码</p>
<ul>
<li>对象序列化/反序列化</li>
<li>服务端函数注册和函数的路由</li>
<li>客户端</li>
</ul>
<p>当然第<code>1, 3</code>部分是很简单啦，但在服务端侧处理<code>RPC</code>函数时，我们要实现运行期函数多态，这里我是利用<code>std::function</code>实现，当然用函数指针肯定也可以</p>
<p>首先是对象序列化，搜了一下很多轮子都是用<code>Protobuf </code>实现对象序列化的，好像是个根据配置文件自动生成类型序列化，反序列化代码的框架</p>
<p>我用的是之前写的一个静态反射宏 + 内部嵌套模板的<a href="https://github.com/zixfy/MyJson">序列化库</a>，本质上也是代码生成器罢了，只不过是<code>C++</code>标准自带的而已。这样我们摆脱了对第三方框架的依赖，坏处是编译器会累一点</p>
<pre><code class="language-c++">DEF_DATA_CLASS(Person, (unsigned short) age, (std::string) name,
               (std::vector&lt;int&gt;) scores);
Person p{24,  &quot;alice&quot;, {3, 4, 89}}; 
cout &lt;&lt; Json{p} &lt;&lt; endl;
cout &lt;&lt; Json{Json{p}.to_type&lt;Person&gt;().value()} &lt;&lt; endl;
//{&quot;age&quot;:24,&quot;name&quot;:&quot;alice&quot;,&quot;scores&quot;:[3,4,89]}
//{&quot;age&quot;:24,&quot;name&quot;:&quot;alice&quot;,&quot;scores&quot;:[3,4,89]}
</code></pre>
<p>用法大概就是这样，现在我们虽然可以（反）序列化对象了，但是我这个实现很<code>naive</code>，从代码可以看出我使用的序列化协议是<code>JSON</code>，使用<code>JSON</code>的话，就会有这些处理与传输开销：转义字符的处理、<code>JSON</code>自描述（每次都要传输字段名字）、不好压缩空字段、<code>JSON</code>文本的递归下降解析</p>
<p>所以其实像<code>Protobuf</code>与<code>Go</code>中<code>net/rpc</code>使用的序列化方案<code>gob</code>都是使用二进制的方案提高性能，所以优化你的<code>rpc</code>时，可以考虑设计一个高效的二进制序列化方案，然后传输在<code>TCP</code>协议上</p>
<p>举栗一个我做<code>MIT 6.5840</code>时遇到的<code>bug</code>说明<code>Go</code>语言中<code>gob</code>对数据空字段的优化</p>
<pre><code>[Worker 1116111] mapping, Task={7 pg-tom_sawyer.txt 0 8 10}
[Worker 1116111] reducing, Task={0  1 8 10}
</code></pre>
<p>这里我是同步顺序调用两个<code>RPC</code>，期望的两个<code>Task</code>返回值如上</p>
<pre><code>[Worker 1117085] mapping, Task={7 pg-tom_sawyer.txt 0 8 10}
[Worker 1117085] reducing, Task={7 pg-tom_sawyer.txt 1 8 10}
</code></pre>
<p>但实际结果是这样的，这里的病灶是，客户端内两个<code>RPC</code>接受返回值的<code>Task</code>对象是同一个，但是前两个字段没有在第二次<code>RPC</code>更新为<code>0</code>和<code>&quot;&quot;</code>，不用想都想得到这里因为是<code>int</code>和<code>string</code>的默认值，服务端应该没有把这两个字段序列化到<code>TCP</code>字节流里。所以说<code>net/rpc</code>假设了客户端是用一个<code>Go</code>中的默认对象（<code>Type{}</code>）来接受返回值的</p>
<p>第二是选择<code>RPC</code>底层的网络协议，认真写的话最好用<code>TCP</code>，多套一层<code>HTTP</code>有额外开销嘛，反正我因为之前用<code>Linux Epoll</code>写了一个<code>HTTP</code>服务器，所以选择在<code>HTTP</code>之上传输，单纯是懒得再写一个应用层协议了..</p>
<p>当我说应用层协议时，我想说的是我们必须要能分辨出<code>RPC</code>数据的边界，有实践过网络编程的话就会知道<code>TCP/UDP</code>传输的是字节流，服务端缓冲区单次读取可能读取的是不完整的<code>RPC</code>请求，或是多个<code>RPC</code>请求</p>
<p>所以使用<code>TCP</code>的话，至少请求起始处要有长度字段标明数据长度给服务端解析</p>
<p>第三是服务端函数注册与路由</p>
<pre><code class="language-c++">namespace my::net::rpc {
    static std::string_view default_route_prefix = &quot;/rpc/&quot;;
    using HandlerType = std::function&lt;std::string(std::string_view)&gt;;
}
</code></pre>
<p>这里我的函数名存在<code>HTTP url</code>中，前缀默认为<code>/rpc/</code></p>
<p>而<code>RPC</code>函数的约束我参考的<code>Go rpc</code>，形参数量必须为<code>1</code>，而且形参和返回值类型必须能被我的<code>Json</code>库序列化，对于每一个<code>RPC</code>函数，创建一个<code>rpc::HandlerType</code>，它是一个输入<code>std::string_view</code>（指向<code>HTTP</code>内存缓冲区内的<code>JSON</code>），输出<code>std::string</code>（序列化的<code>RPC</code>返回值）的<code>std::function</code></p>
<pre><code class="language-c++">namespace my::net::http {
    
using RpcFuncTable = std::unordered_map&lt;std::string, rpc::HandlerType&gt;;
    // ...
	RpcFuncTable m_rpc_funcs;
    // ...
    
template &lt;typename Func&gt;
  bool rpc_register(std::string const &amp;name, Func func) {
    auto url = std::string{rpc::default_route_prefix} + name;
    // $&quot;/rpc/{name}&quot;
    if (m_rpc_funcs.find(url) != m_rpc_funcs.end())
      return false;
    m_rpc_funcs[url] = [f = func](std::string_view content) -&gt; std::string {
      using namespace MyJson;
      auto j = Json::from_json_text(content);
      // ...
      using ArgT = std::remove_cv_t&lt;std::remove_reference_t&lt;rpc::FirstArgT&lt;Func&gt;&gt;&gt;; 
      auto arg = j.value().to_type&lt;ArgT&gt;();
      // ...
      return Json{f(arg.value())}.to_json_text();
    };
    return true;
  }
}
</code></pre>
<p>所以服务端维护一个函数名到相应<code>HandlerType</code>的哈希<code>m_rpc_funcs</code>就可以</p>
<p>当通过<code>rpc_register&lt;Func&gt;</code>注册一个类型为<code>Func</code>的新函数（<code>C++</code>函数或函数指针或函数对象）时，利用<code>lambda</code>写一个函数装饰器，生成的闭包也输入<code>string_view</code>，返回<code>string</code>，所以可以在哈希表里构造一个对应的<code>rpc::HandlerType</code>（也就是<code>std::function&lt;std::string(std::string_view)&gt;</code>）</p>
<p>闭包内部反序列化、调用注册的函数、序列化就完成了<code>RPC</code>函数的多态</p>
<p>其中有一个<code>rpc::FirstArgT&lt;Func&gt;</code>模板，是用于获取函数那单个形参类型的，如果函数是一个<code>C++</code>函数对象<code>f</code>，比如<code>lambda</code>，那我们调用<code>f</code>时实际调用的是<code>f.operator()</code>，所以这个模板对函数指针和函数对象作了不同的特化</p>
<pre><code class="language-c++">template &lt;typename T&gt; struct arg_type;
// function
template &lt;typename R, typename Arg&gt; struct arg_type&lt;R(Arg)&gt; { 
   using type = Arg; };
// function pointer
template &lt;typename R, typename Arg&gt; struct arg_type&lt;R (*)(Arg)&gt; { 
   using type = Arg; };
// member function pointer
template &lt;typename C, typename R, typename Arg&gt; struct arg_type&lt;R (C::*)(Arg)&gt; { 
   using type = Arg; };
// const member function pointer
template &lt;typename C, typename R, typename Arg&gt; struct arg_type&lt;R (C::*)(Arg) const&gt; {
   using type = Arg;};
template &lt;typename F, typename = void&gt; struct first_type { 
   using type = typename arg_type&lt;F&gt;::type; };
template &lt;typename F&gt; struct first_type&lt;F, std::enable_if_t&lt;std::is_class_v&lt;F&gt;&gt;&gt; {
   using type = typename arg_type&lt;decltype(&amp;F::operator())&gt;::type;}; 

template &lt;typename F&gt; using FirstArgT = typename detail::first_type&lt;F&gt;::type;
</code></pre>
<p>接下来只要让服务端正确路由<code>RPC</code>请求到相应的<code>rpc::HandlerType</code>，然后返回<code>HTTP</code>报文</p>
<pre><code class="language-c++">auto rpc_url = std::string{request.url};
if (rpc_table.find(rpc_url) != rpc_table.end()) {
    auto res = rpc_table[rpc_url](request.content);
    m_keep_alive = request.keep_alive;
    std::stringstream ss;
    ss &lt;&lt; &quot;HTTP/1.1 200 OK\r\n&quot;;
    ss &lt;&lt; &quot;Connection: &quot; &lt;&lt; (m_keep_alive ? &quot;keep-alive&quot; : &quot;close&quot;) &lt;&lt; &quot;\r\n&quot;;
    ss &lt;&lt; &quot;Content-Length: &quot; &lt;&lt; res.size() &lt;&lt; &quot;\r\n\r\n&quot;;
    ss &lt;&lt; res;
    m_response_buffer.s = ss.str();
}
</code></pre>
<p>第四是写客户端，到这部分就是纯搬砖了..</p>
<pre><code class="language-c++">Client cli;
cli.dial(&quot;/*server_addr*/:/*server_port*/&quot;);
cout &lt;&lt; cli.call&lt;string, string&gt;(&quot;echo&quot;, &quot;i am client, rpc okay&quot;).value() &lt;&lt; endl;
</code></pre>
<p>类似<code>Go rpc</code>先写一个<code>dial</code>函数指定<code>RPC</code>服务端<code>IP</code></p>
<p>然后写一个模板函数<code>call&lt;ArgT, ResT&gt;</code>指明<code>RPC</code>调用的输入输出类型，这里<code>call</code>使用短连接的话，每次<code>connect</code>一次服务端发送<code>HTTP</code>请求</p>
<pre><code class="language-c++">bool dial(const std::string &amp;address);

template &lt;typename ArgT, typename ResT&gt;
std::optional&lt;ResT&gt; call(std::string const &amp;name, ArgT const &amp;arg)
</code></pre>
<p>测试一下，先定义数据类型</p>
<pre><code class="language-c++">namespace MyTypeList {
    DEF_DATA_CLASS(Arg, (float) a, (int) b)
}
</code></pre>
<p>然后在服务器上注册两个<code>RPC</code>函数，分别是<code>lambda</code>和普通函数</p>
<pre><code class="language-c++">using namespace my; 
using namespace std;
using namespace MyTypeList; 
string f(Arg a) {
  return string {&quot;[Server Add]&quot;} 
    + std::to_string(a.a) + &quot; + &quot;
    + std::to_string(a.b) + &quot; = &quot;
    + std::to_string(a.b + a.a);
}
auto main(int argc, char *argv[]) -&gt; int {
  // ...
  auto server = net::http::Reactor(config);
  server.rpc_register(&quot;echo&quot;, [](const std::string &amp;x) {
    return std::string{&quot;[Server Echo] &quot;} + x;
  });

  server.rpc_register(&quot;calculate&quot;, f);
  server.run();
}
</code></pre>
<p>我的服务端与客户端<code>Log</code>分别成功打印了</p>
<pre><code>[********:49632][200](RPC) method=&quot;POST&quot;, url=&quot;/rpc/echo&quot;, version=&quot;HTTP/1.1&quot;, host=&quot;&quot;, keep-alive=false, content-length=23, content=&quot;i am client, rpc okay&quot;
[********:49640][200](RPC) method=&quot;POST&quot;, url=&quot;/rpc/calculate&quot;, version=&quot;HTTP/1.1&quot;, host=&quot;&quot;, keep-alive=false, content-length=20, content={&quot;a&quot;:7.59506,&quot;b&quot;:19}
[********:49650][200](RPC) method=&quot;POST&quot;, url=&quot;/rpc/calculate&quot;, version=&quot;HTTP/1.1&quot;, host=&quot;&quot;, keep-alive=false, content-length=20, content={&quot;a&quot;:1.42983,&quot;b&quot;:15}
[********:49652][200](RPC) method=&quot;POST&quot;, url=&quot;/rpc/calculate&quot;, version=&quot;HTTP/1.1&quot;, host=&quot;&quot;, keep-alive=false, content-length=19, content={&quot;a&quot;:11.4494,&quot;b&quot;:2}
[********:49668][200](RPC) method=&quot;POST&quot;, url=&quot;/rpc/calculate&quot;, version=&quot;HTTP/1.1&quot;, host=&quot;&quot;, keep-alive=false, content-length=19, content={&quot;a&quot;:12.5055,&quot;b&quot;:3}
[********:49682][200](RPC) method=&quot;POST&quot;, url=&quot;/rpc/calculate&quot;, version=&quot;HTTP/1.1&quot;, host=&quot;&quot;, keep-alive=false, content-length=20, content={&quot;a&quot;:3.33604,&quot;b&quot;:15}
</code></pre>
<p>和</p>
<pre><code>[Server Echo] i am client, rpc okay
[Server Add]7.595060 + 19 = 26.595060
[Server Add]1.429830 + 15 = 16.429831
[Server Add]11.449400 + 2 = 13.449400
[Server Add]12.505500 + 3 = 15.505500
[Server Add]3.336040 + 15 = 18.336040
</code></pre>
<p><strong>Full Code</strong>: [<a href="https://github.com/zixfy/SimpleWebServer/blob/main/main.cpp">server</a>, <a href="https://github.com/zixfy/SimpleWebServer/blob/main/rpc_client.cpp">rpc_client</a>]</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Index]]></title>
        <id>http://zixfy.github.io/post/repos/</id>
        <link href="http://zixfy.github.io/post/repos/">
        </link>
        <updated>2023-10-08T15:31:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="zhihu">Zhihu</h2>
<p><a href="https://www.zhihu.com/people/leon-87-10">https://www.zhihu.com/people/leon-87-10</a></p>
<h2 id="leetcode">Leetcode</h2>
<p><a href="https://leetcode.cn/u/zixfy/">https://leetcode.cn/u/zixfy/</a></p>
<h2 id="github">Github</h2>
<p><strong>pyACLL-inference</strong></p>
<div style="display: flex; justify-content: flex-start;">
    <img src="https://img.shields.io/badge/license-MIT-blue?logo=git&link=http%3A%2F%2Fgitlab.buaadml.info%2Fbdi%2Fpyacl-inference%2F-%2Fblob%2Fmain%2FLICENSE"  style="margin: 5px">
    <img src="https://img.shields.io/badge/python-%3E%3D3.8-blue?logo=python"  style="margin: 5px">
    <img src="https://img.shields.io/badge/Gitee-samples-red?logo=gitee&cacheSeconds=https%3A%2F%2Fgitee.com%2Fascend%2Fsamples"  style="margin: 5px">
        <img src="https://img.shields.io/badge/huawei-CANN-red?logo=huawei&logoColor=red&link=https%3A%2F%2Fwww.hiascend.com%2Fzh%2Fsoftware%2Fcann"  style="margin: 5px">
</div>
<p>[<a href="https://github.com/zixfy/pyACL-inference/">Github</a>] 一个华为<code>CANN</code> <code>.om</code>模型数据并行推理的接口(<code>AscendCL with python</code>)</p>
<p><strong>leecode-cplusplus-solution</strong></p>
<div style="display: flex; justify-content: flex-start;">
    <img src="https://img.shields.io/badge/LICENSE-MIT-blue?logo=git&logoColor=orange"  style="margin: 5px">
    <img src="https://img.shields.io/badge/C%2B%2B-17-blue?logo=cplusplus&logoColor=blue"  style="margin: 5px">
    <img src="https://img.shields.io/badge/Leetcode-Zixfy-pink?style=social&logo=leetcode&logoColor=orange"  style="margin: 5px"> 
</div> 
<p>[<a href="https://github.com/zixfy/cpp-advanced-container-template">Github</a>] 力扣<code>C++</code>题目</p>
<p><strong>Advanced data structures Implement in C++</strong></p>
<div style="display: flex; justify-content: flex-start;">
    <img src="https://img.shields.io/badge/license-MIT-blue?logo=git&logoColor=%20"  style="margin: 5px">
    <img src="https://img.shields.io/badge/C%2B%2B-20-green?logo=cplusplus&logoColor=blue"  style="margin: 5px">
    <img src="https://img.shields.io/badge/cmake-3.22%2B-green?logo=cmake&logoColor=deepskyblue"  style="margin: 5px">
        <img src="https://img.shields.io/badge/compiler-x86%20MSVC%2019.29%2B-green?logo=compilerexplorer"  style="margin: 5px">
</div> 
<p>[<a href="https://github.com/zixfy/cpp-advanced-container-template">Github</a>] 一些数据结构与算法在<code>C++</code>的模板实现</p>
<p><strong>MyJson</strong></p>
<div style="display: flex; justify-content: flex-start;">
    <img src="https://img.shields.io/badge/license-MIT-blue?logo=git&logoColor=%20"  style="margin: 5px">
    <img src="https://img.shields.io/badge/C%2B%2B-17-green?logo=cplusplus&logoColor=blue"  style="margin: 5px">
    <img src="https://img.shields.io/badge/cmake-3.22%2B-green?logo=cmake&logoColor=deepskyblue"  style="margin: 5px">
        <img src="https://img.shields.io/badge/compiler-x86%20gcc%2011.3+-green?logo=compilerexplorer"  style="margin: 5px">   <img src="https://img.shields.io/badge/compiler-x86%20MSVC%2019.29%2B-green?logo=compilerexplorer"  style="margin: 5px">
</div> 
<p>[<a href="https://github.com/zixfy/MyJson">Github</a>] 利用静态反射宏的对象序列化</p>
<p><strong>SimpleWebServer</strong></p>
<div style="display: flex; justify-content: flex-start;">
    <img src="https://img.shields.io/badge/license-MIT-blue?logo=git&logoColor=%20"  style="margin: 5px">
    <img src="https://img.shields.io/badge/C%2B%2B-17-green?logo=cplusplus&logoColor=blue"  style="margin: 5px">
    <img src="https://img.shields.io/badge/cmake-3.22%2B-green?logo=cmake&logoColor=deepskyblue"  style="margin: 5px">
        <img src="https://img.shields.io/badge/Linux-18.04%20LTS-green?logo=linux&logoColor=%20"  style="margin: 5px">   
        <img src="https://img.shields.io/badge/github-fmt10.1.0-blue?logo=github&logoColor=%20&link=https%3A%2F%2Fgithub.com%2Ffmtlib%2Ffmt"  style="margin: 5px">
</div>  
<p>[<a href="https://github.com/zixfy/SimpleWebServer">Github</a>] 多线程单<code>Reactor</code>静态<code>HTTP</code>服务器</p>
<h2 id="题解索引">题解索引</h2>
<p><a href="/post/leetcode-2262-zi-fu-chuan-de-zong-yin-li/">【Leetcode】2262. 字符串的总引力</a><br>
<a href="/post/leetcode/">【Leetcode】2449. 使数组相似的最少操作次数</a><br>
<a href="/post/leetcode-2503-ju-zhen-cha-xun-ke-huo-de-de-zui-da-fen-shu">【Leetcode】2503. 矩阵查询可获得的最大分数</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在C++中创建具名元组(namedtuple)]]></title>
        <id>http://zixfy.github.io/post/zai-czhong-chuang-jian-ju-ming-yuan-zu-namedtuple/</id>
        <link href="http://zixfy.github.io/post/zai-czhong-chuang-jian-ju-ming-yuan-zu-namedtuple/">
        </link>
        <updated>2023-10-08T15:30:17.000Z</updated>
        <content type="html"><![CDATA[<p>创作于<a href="https://zhuanlan.zhihu.com/p/659506997">zhihu</a></p>
<p>首先不建议使用<code>std::tuple</code>，<code>tuple</code>是给模板，而不是正常代码用的</p>
<p>泛型中，有时我们不得不根据变长的<code>typename</code>保存对象（<code>std::tuple&lt;type_trait&lt;T&gt;...&gt;</code>）</p>
<p>因为我们没法直接在模板类里根据变长的<code>typename</code>存储变长的不同类型成员..</p>
<p>比如像实现一个这样回滚的功能</p>
<pre><code class="language-c++">template &lt;size_t I, typename Tup, typename  Lhs, typename ...Oth&gt;
void impl(Tup const &amp; t, Lhs &amp; lhs, Oth &amp; ...oth) {
    lhs = std::get&lt;I&gt;(t);
    if constexpr (sizeof...(oth) &gt; 0) impl&lt;I + 1, Tup, Oth...&gt;(t, oth...);
};
auto snapshot = [](auto &amp;...arg) {
  return [&amp;, rhs = std::tuple&lt;std::remove_reference_t&lt;decltype(arg)&gt;...&gt;{
                 arg...}]() { impl&lt;0&gt;(rhs, arg...); };
};

int main() {
  int a = 1, b = 2; string c = &quot;2.33&quot;;
  auto rollback = snapshot(a, b, c);
  try {
      a = b = 3;  c = &quot;1&quot;;
      throw 0;
  } catch (...) {
      rollback();
  }
  cout &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;, &quot; &lt;&lt; c;
//1, 2, 2.33
}
</code></pre>
<p>但在其他场景下，我们应该首先使用聚合体替代<code>tuple</code>，因为<code>tuple</code>一般通过多继承或递归继承实现，引入了额外开销</p>
<p>其次<code>tuple</code>没有可读性，如果我需要匿名类型，我会先质疑自己是不是在写屎山..</p>
<p>而且<code>C++ 17</code>中，我们可以对<code>struct</code>使用结构化绑定了</p>
<pre><code class="language-c++">struct Person {short age; int id; string name;}
auto&amp; [a, i, n] = Person{17, 32, &quot;bob&quot;};
</code></pre>
<p>如果我们真的需要拿<code>tuple</code>来存数据的话（比如让类型兼容<code>std::apply</code>或其他模板），也至少要实现具名元组(<code>namedtuple</code>)的机制，因为对<code>tuple</code>取单个成员时，硬编码的<code>std::get&lt;0&gt;</code>,<code>std::get&lt;1&gt;</code> ... 很脆弱，匿名字段让代码可维护性变得很差</p>
<p>首先我们可以使用<code>enum</code>变量名来作为<code>namedtuple</code>中的字段名</p>
<p>先定义一个模板类</p>
<pre><code class="language-c++">template &lt;typename T&gt; struct Named;
</code></pre>
<p>特化一个<code>Named</code>，存储对应<code>tuple</code>类型与枚举</p>
<pre><code class="language-c++">struct Person;
template &lt;&gt; struct Named&lt;Person&gt; {
  enum { name = 0, address, id, age };
  using Tuple = tuple&lt;string, string, int, short&gt;;
};
</code></pre>
<p>其中<code>enum</code>是匿名弱枚举，枚举变量名会上升到<code>Named&lt;Person&gt;</code></p>
<p>之后可以这样使用</p>
<pre><code class="language-c++">int main() {
  Named&lt;Person&gt;::Tuple t{&quot;alice&quot;, &quot;CN&quot;, 114514, 17};
  cout &lt;&lt; get&lt;Named&lt;Person&gt;::name&gt;(t) &lt;&lt; endl;
  cout &lt;&lt; get&lt;Named&lt;Person&gt;::address&gt;(t) &lt;&lt; endl;
  cout &lt;&lt; get&lt;Named&lt;Person&gt;::age&gt;(t) &lt;&lt; endl;
}
</code></pre>
<p>但是这样的话，<code>enum</code>里的名字和存储类型就分裂开了，也就是使用中不能方便地查看某个名字对应什么类型，可能看差眼了</p>
<p>这种写法不够优雅，除了拿变量名当名字，我们其实所以可以把<strong>另一个类型名</strong>作为具名元组中的字段名</p>
<p>然后使用<code>std::pair</code> 绑定字段名和字段类型</p>
<p>这样通过简单的元编程，我们就可以实现一个比较好维护的<code>namedtuple</code>，写法如下</p>
<pre><code class="language-c++">namespace MyTypeList {
template &lt;typename U, typename V&gt; using _ = pair&lt;U, V&gt;;
struct name; struct address; struct age; struct id; struct master;
using Person = DefineNamedTuple&lt;_&lt;name, string&gt;,  _&lt;address, string&gt;, _&lt;id, int&gt;, _&lt;age, short&gt;&gt;;
using Dog = DefineNamedTuple&lt;_&lt;master, Person::Tuple&gt;, _&lt;name, string&gt;&gt;;
}; // namespace MyTypeList
</code></pre>
<p>因为使用类型名作为名字，所以我们要使用一个<code>namespace</code>封住这些名字防止污染代码中其他类</p>
<p>核心是实现<code>DefineNamedTuple&lt;pair&lt;Name, Type&gt;...&gt;</code></p>
<pre><code class="language-c++">template &lt;typename... NameAndTypes&gt; struct DefineNamedTuple {
  using Tuple = std::tuple&lt;typename UnPackPair&lt;NameAndTypes&gt;::second...&gt;;
  template &lt;typename T&gt; struct Index_ {
    template &lt;std::size_t I, typename U, typename... V&gt; struct Helper {
      constexpr inline static std::size_t _v =
          std::is_same_v&lt;T, typename UnPackPair&lt;U&gt;::first&gt;
              ? I
              : Helper&lt;I + 1, V...&gt;::_v;
    };
    template &lt;std::size_t I, typename U&gt; struct Helper&lt;I, U&gt; {
      constexpr inline static std::size_t _v =
          std::is_same_v&lt;T, typename UnPackPair&lt;U&gt;::first&gt; ? I
                                                           : I + 1;
    };
    constexpr inline static std::size_t _v = Helper&lt;0, NameAndTypes...&gt;::_v;
  };
  template &lt;typename T&gt; constexpr inline static std::size_t At = Index_&lt;T&gt;::_v;
};
</code></pre>
<p>这个模板类接收变长的<code>NameAndTypes</code>(<code>pair</code>)，首先定义了<code>Tuple</code>别名，解构出<code>pair</code>中存储的实际值类型，然后得到实际<code>tuple</code>类型</p>
<p>其次内部有一个模板变量<code>At&lt;T&gt;</code>让编译器计算名字<code>T</code>对应的<code>tuple</code>下标</p>
<p>核心是内部的<code>Helper</code>递归模板</p>
<pre><code class="language-c++">template &lt;std::size_t I, typename U, typename... V&gt; struct Helper 
</code></pre>
<p>表示当前遍历下标为<code>I</code>，<code>tuple</code>中下标<code>I</code>对应的名字是<code>U::first</code>，下标<code>I</code>以后的名字是<code>V::first...</code></p>
<pre><code class="language-c++">std::is_same_v&lt;T, typename UnPackPair&lt;U&gt;::first&gt;
              ? I
              : Helper&lt;I + 1, V...&gt;::_v;
</code></pre>
<p>所以如果当前名字是<code>T</code>，返回<code>I</code>，否则<code>++I</code>，在之后的名字<code>V::first...</code>中查找</p>
<pre><code class="language-c++">template &lt;std::size_t I, typename U&gt; struct Helper&lt;I, U&gt; {
    constexpr inline static std::size_t _v =
        std::is_same_v&lt;T, typename UnPackPair&lt;U&gt;::first&gt; 
            ? I
            : I + 1;
};
</code></pre>
<p>再特化一个<code>Helper</code>模板表示递归边界（查找到了最后一个名字<code>U::first</code>）</p>
<p>其中的<code>UnpackPair&lt;U, V&gt;</code>用于解构<code>pair</code>:</p>
<pre><code class="language-c++">template &lt;typename U&gt; struct UnPackPair;
template &lt;typename U, typename V&gt; struct UnPackPair&lt;pair&lt;U, V&gt;&gt; {
  using first = U;
  using second = V;
};
</code></pre>
<p>使用举栗：</p>
<pre><code class="language-c++">int main() {
  using namespace MyTypeList;
  Person::Tuple t{&quot;alice&quot;,  &quot;CN&quot;, 114514, 17};
  Dog::Tuple t2{t, &quot;big black&quot;};
  cout &lt;&lt; get&lt;Person::At&lt;name&gt;&gt;(t) &lt;&lt; endl;
  cout &lt;&lt; get&lt;Person::At&lt;address&gt;&gt;(t) &lt;&lt; endl;
  cout &lt;&lt; get&lt;Person::At&lt;age&gt;&gt;(t) &lt;&lt; endl;
  cout &lt;&lt; get&lt;Person::At&lt;id&gt;&gt;(t) &lt;&lt; endl;
  cout &lt;&lt; get&lt;Dog::At&lt;name&gt;&gt;(t2) &lt;&lt; endl;
  cout &lt;&lt; get&lt;Person::At&lt;id&gt;&gt;(get&lt;Dog::At&lt;master&gt;&gt;(t2)) &lt;&lt; endl;
}
// alice
// CN
// 17
// 114514
// big black
// 114514
</code></pre>
<p>完整实现：<a href="https://link.zhihu.com/?target=https%3A//gist.github.com/zixfy/65728e0457cddef17ff3e8d9d2ce1292">Gist</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解决C++多继承中override虚函数签名冲突]]></title>
        <id>http://zixfy.github.io/post/jie-jue-cduo-ji-cheng-zhong-override-xu-han-shu-qian-ming-chong-tu/</id>
        <link href="http://zixfy.github.io/post/jie-jue-cduo-ji-cheng-zhong-override-xu-han-shu-qian-ming-chong-tu/">
        </link>
        <updated>2023-10-08T15:29:58.000Z</updated>
        <content type="html"><![CDATA[<p>创作于：<a href="https://zhuanlan.zhihu.com/p/659417326">zhihu</a></p>
<p><code>C++</code>本身并没有提供标准的接口（<code>Interface</code>）类型</p>
<p>所以我们可以有各种方式来实现接口机制</p>
<p>考虑面向对象的范式，<code>C++</code>提供了纯虚函数，所以我们可以自然地使用抽象类作为接口类型</p>
<p>纯虚函数是以<code>= 0</code>声明的虚函数（什么怪语法..）</p>
<p>如果一个类内部有纯虚函数，或者继承链上有没被实现的纯虚函数，那么这个类成为抽象类</p>
<p>抽象类对象无法构造，我们只能利用它的引用或指针类型多态，而实际派生出来的类通过继承抽象类并<code>override</code>纯虚函数来实现接口</p>
<p>一个简单的接口例子</p>
<pre><code class="language-c++">struct IPrintable {
  virtual void print() = 0;
};

struct StrangePrinter : IPrintable {
  void print() override {
    cout &lt;&lt; &quot;StrangePrinter::print() hola, amigo!&quot; &lt;&lt; endl;
  }
};

struct NormalPrinter : IPrintable {
  void print() override {
    cout &lt;&lt; &quot;NormalPrinter::print() hello, world!&quot; &lt;&lt; endl;
  }
};

int main() {
  using PrinterPtr = IPrintable*;
  StrangePrinter s;
  NormalPrinter n;
  PrinterPtr ps = &amp;s, pn = &amp;n;
  ps-&gt;print();
  pn-&gt;print();
}
//output:
//StrangePrinter::print() hola, amigo!
//NormalPrinter::print() hello, world!
</code></pre>
<p>当然实际中我们不可能每个类只实现一个接口吧，如果是，是不是该考虑解耦了？</p>
<p><code>C++</code>支持多重继承，所以我们直接让实际类继承多个抽象类实现多个接口</p>
<p>但是如果多个接口内有相同签名的纯虚函数该如何应对</p>
<p>比如我有一个<code>IHasMinimum&lt;T&gt;</code>接口，<code>value()</code>返回<code>T</code>的最小值，和一个<code>IHasMaximum&lt;T&gt;</code>接口，<code>value()</code>返回<code>T</code>的最大值</p>
<p>然后又有一个<code>IHasBound&lt;T&gt;</code>，其<code>min(), max()</code>分别返回<code>T</code>的最小（大）值，所以让<code>IHasBound&lt;T&gt;</code>接口去实现<code>IHasMinimum&lt;T&gt;</code>和<code>IHasMaximum&lt;T&gt;</code>接口很合理吧</p>
<pre><code class="language-c++">template &lt;typename T&gt; struct IHasMinimum {
  virtual T value() = 0;
};

template &lt;typename T&gt; struct IHasMaximum {
  virtual T value() = 0;
};
template &lt;typename T&gt;
struct IHasBound : public IHasMinimum&lt;T&gt;, public IHasMaximum&lt;T&gt; {
  virtual T min() = 0;
  virtual T max() = 0;
    // override IHasMinimum::value and IHasMaximum::value ???
}
</code></pre>
<p>但是这俩接口的<code>value</code>签名都是<code>value()</code>，如果<code>IHasBound</code>内<code>override</code>了<code>value</code>，<code>IHasMinimum</code>，<code>IHasMaximum</code>的<code>value()</code>都会被<code>override</code>，一个要返回最大值，一个要最小值，不能返回相同的值啊..</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct IHasBound : public IHasMinimum&lt;T&gt;, public IHasMaximum&lt;T&gt; {
  T value() override { /*...*/ }
    // override both IHasMinimum::value and IHasMaximum::value 
}
</code></pre>
<p>也许改个函数名就解决问题了，比如两个<code>value</code>改名成<code>min_value</code>，<code>max_value</code></p>
<p>但也许 1. 我们改不了父类代码 2. 取不出更好的名字 3. 承担不了重命名的痛</p>
<p>如果可以这样分别为<code>IHasMinimum</code>和<code>IHasMaximum</code>  <code>override</code>两个版本的<code>value()</code>就好了</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct IHasBound : public IHasMinimum&lt;T&gt;, public IHasMaximum&lt;T&gt; {
  T IHasMinimum&lt;T&gt;::value() override { /*...*/ }  
  T IHasMaximum&lt;T&gt;::value() override { /*...*/ }  
}
</code></pre>
<p>但<code>C++</code>好像不支持这样的机制，<code>C#</code>是支持的</p>
<p>所以可以这样曲线救国，我们在<code>IHasBound</code>和<code>IHasMinimum/IHasMaximum</code>间分别再加一个新类，新类实现<code>value()</code>，<code>override</code>的方法中向下转型获取<code>IHasBound</code>的<code>this</code>指针</p>
<p>为了减少垃圾命名，先定义一个模板类</p>
<pre><code class="language-c++">template &lt;typename Interface, typename Struct&gt; struct Impl;
</code></pre>
<p>然后这样</p>
<pre><code class="language-c++">template &lt;typename T&gt; struct IHasMinimum {
  virtual T value() = 0;
};
template &lt;typename T&gt; struct IHasMaximum {
  virtual T value() = 0;
};

template &lt;typename T&gt; struct IHasBound;

template &lt;typename T&gt;
struct Impl&lt;IHasMaximum&lt;T&gt;, IHasBound&lt;T&gt;&gt; : public IHasMaximum&lt;T&gt; {
  T value() override { return static_cast&lt;IHasBound&lt;T&gt; *&gt;(this)-&gt;max(); }
};
template &lt;typename T&gt;
struct Impl&lt;IHasMinimum&lt;T&gt;, IHasBound&lt;T&gt;&gt; : public IHasMinimum&lt;T&gt; {
  T value() override { return static_cast&lt;IHasBound&lt;T&gt; *&gt;(this)-&gt;min(); }
};

template &lt;typename T&gt;
struct IHasBound : public Impl&lt;IHasMaximum&lt;T&gt;, IHasBound&lt;T&gt;&gt;,
                   public Impl&lt;IHasMinimum&lt;T&gt;, IHasBound&lt;T&gt;&gt; {
  virtual T min() = 0;
  virtual T max() = 0;
};
</code></pre>
<p>就好了，一个使用栗子，创建<code>Range&lt;T&gt;</code>类实现<code>IHasBound</code>，就可以同时也实现<code>IHasMinimum/IHasMaximum</code>了</p>
<pre><code class="language-c++">template &lt;typename T&gt; struct Range : public IHasBound&lt;T&gt; {
  T _mini, _maxi;
  T min() override { return _mini; }
  T max() override { return _maxi; }
  Range(T mini, T maxi) : _mini{mini}, _maxi{maxi} {}
};

int main() { 
  Range d(114.514, 1919.810);
  IHasMinimum&lt;double&gt; &amp;i1 = d;
  IHasMaximum&lt;double&gt; &amp;i2 = d;
  IHasBound&lt;double&gt; &amp;i3 = d;
  IHasBound&lt;double&gt; *i4 = &amp;d;
  std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(3);
  std::cout &lt;&lt; &quot;IHasMinimum::value(): &quot; &lt;&lt; i1.value() &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;IHasMaximum::value(): &quot; &lt;&lt; i2.value() &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;IHasBound::min(): &quot; &lt;&lt; i3.min() &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;IHasBound::max(): &quot; &lt;&lt; i3.max() &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;IHasBound-&gt;min(): &quot; &lt;&lt; i4-&gt;min() &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;IHasBound-&gt;max(): &quot; &lt;&lt; i4-&gt;max() &lt;&lt; std::endl;
}
//IHasMinimum::value(): 114.514
//IHasMaximum::value(): 1919.810
//IHasBound::min(): 114.514
//IHasBound::max(): 1919.810
//IHasBound-&gt;min(): 114.514
//IHasBound-&gt;max(): 1919.810
</code></pre>
<p>btw，如果实现类不是模板类，以上写法可能会有<code>incomplete type</code>错误</p>
<p>这时可以使用<code>CRTP</code>，大概这么写</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

template &lt;typename Interface, typename Struct&gt; struct Impl;
struct Base1 {
  virtual void fun() = 0;
};

struct Base2 {
  virtual void fun() = 0;
};

struct child;
template &lt;std::same_as&lt;child&gt; T&gt; struct Impl&lt;Base1, T&gt; : public Base1 {
  void fun() override {
    cout &lt;&lt; static_cast&lt;T *&gt;(this)-&gt;name &lt;&lt; &quot;, hello from override for Base1&quot; &lt;&lt; endl;
  }
};
template &lt;std::same_as&lt;child&gt; T&gt; struct Impl&lt;Base2, T&gt; : public Base2 {
  void fun() override { cout &lt;&lt; static_cast&lt;T *&gt;(this)-&gt;name &lt;&lt; &quot;, hello from override for Base2&quot; &lt;&lt; endl; }
};

struct child : public Impl&lt;Base1, child&gt;, public Impl&lt;Base2, child&gt; {
    string name{&quot;iam child&quot;};
};
int main() {
  child c;
  Base1 &amp;b1 = c;
  Base2 &amp;b2 = c;
  b1.fun();
  // hello from override for Base1
  b2.fun();
  // hello from override for Base2
  //c.fun();
  // ERROR: member found by ambiguous name lookup
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[用C++实现C#的属性（Properties）]]></title>
        <id>http://zixfy.github.io/post/yong-cshi-xian-cde-shu-xing-properties/</id>
        <link href="http://zixfy.github.io/post/yong-cshi-xian-cde-shu-xing-properties/">
        </link>
        <updated>2023-10-08T15:28:13.000Z</updated>
        <content type="html"><![CDATA[<p>设想这样一个场景，我们正在写一个通过代码生成<code>markdown</code>的脚本</p>
<p><code>markdown</code>中行内代码的语法为`code`，相应显示为<code>code</code></p>
<p>对应到编码中，我们可以创建一个<code>InlineCode</code>类维护这种<code>markdown</code>元素</p>
<p>考虑到反引号只在输出<code>markdown</code>时需要，且反引号内的内容可能频繁修改</p>
<p>所以我们用一个<code>string</code>成员变量<code>_text</code>维护反引号内的内容(code)，而不是整个行内代码(`code`)</p>
<p>而且修改内容后，我们可能还有些其他操作，比如说检查内容语法正确性啥的whatever</p>
<p>反正我们现在最好把<code>_text</code>变成私有的，然后定义<code>set_text</code>，<code>get_formatted_text</code>成员函数读写内容</p>
<p>但这样代码的可读性就有点太好了 XD</p>
<p>如果我们只用暴露一个成员<code>text</code>给使用者，让<code>text</code>可以像一个<code>string</code>一样被使用，也就是它被读写时自动调用<code>set_text</code>，<code>get_formatted_text</code>就好了</p>
<p><code>C#</code>原生支持这种代理模式，我们在<code>C#</code>中可以将<code>InlineCode</code>类实现如下</p>
<pre><code class="language-c#">public class InlineCode
{
    private string _text; 
    private void _notify(string old, string newer)
    { Console.WriteLine($&quot;InlineCode.Text modified from `{old}` to `{newer}`&quot;);}

    public string Text
    {
        get =&gt; $&quot;`{_text}`&quot;;
        set {  _notify(_text, value); _text = value; }
    }

    public string Style, Dom; 
	// and may have other members, omit
    public InlineCode() { }
};
</code></pre>
<p><code>C# Properties</code>在<code>MSLearn</code>上的<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/using-properties">介绍</a></p>
<p>简单来说，对于一个类型为<code>T</code>的<code>C#</code>字段<code>Prop</code></p>
<p>其<code>get</code>必须满足委托类型（也就是函数签名+返回值类型）为<code>T()</code>，<code>set</code>委托也必须为<code>void(T)</code>的形式</p>
<p>当读取<code>Prop</code>时，返回<code>get()</code>，当赋值<code>Prop</code>时，调用<code>set(value)</code>，其中<code>value</code>是赋值表达式右手侧</p>
<p>所以上述代码中，<code>Text</code>属性<code>get</code>返回带反引号的内容，注意<code>set</code>的<code>value</code>形参的声明在语法上省略了</p>
<pre><code class="language-c++">class Program
{
    static void Main(string[] args)
    {
        var code = new InlineCode();
        code.Text = &quot;Rust&quot;;
        Console.WriteLine(code.Text);
    }
}
</code></pre>
<p>所以使用<code>InlineCode</code>类时，只用关注内部文本内容，上述代码可以得到以下期望结果</p>
<pre><code class="language-c++">InlineCode.Text modified from `` to `Rust`
`Rust`
</code></pre>
<p>现在考虑以下类似机制在<code>C++</code>中的实现</p>
<p><strong>第1版代码:</strong></p>
<pre><code class="language-c++">template &lt;typename T&gt; class Field {
  using Getter = std::function&lt;T()&gt;;
  using Setter = std::function&lt;void(const T &amp;)&gt;;
  Getter _get;
  Setter _set;

public:
  explicit Field( Getter getter = {}, Setter setter = {})
      : _get{getter},
        _set{setter} {}

  T get() { return _get(); }
  operator T() { return _get(); }

  Field &amp;operator=(const T &amp;arg) {
    _set(arg);
    return *this;
  }
};
</code></pre>
<p>创建代理类<code>Field&lt;T&gt;</code>，参考<code>C#</code>，将<code>get</code>的类型<code>Getter</code>定义为<code>std::function&lt;T()&gt;</code>，将<code>get</code>的类型<code>Getter</code>定义为<code>std::function&lt;void(const T &amp;)&gt;</code></p>
<p>这样，只要分别用一个<code>_get</code>和<code>_set</code>变量保存<code>Getter/Setter</code></p>
<p>然后再定义<code>T get()</code>并重载它的<code>operator T() </code>用于读取（<code>_get()</code>），重载<code>Field &amp;operator=(const T &amp;arg)</code>用于修改<code>_set(arg)</code></p>
<p>在函数体中的使用：</p>
<pre><code class="language-c++">int main() {
  string str = &quot;default&quot;;
  auto quoted_getter = [&amp;]( ) { return &quot;`&quot; + str + &quot;`&quot;; };
  auto quoted_setter = [&amp;](const string&amp;s){ cout &lt;&lt; &quot;modified from `&quot; &lt;&lt; str &lt;&lt; &quot;` to `&quot; &lt;&lt; s &lt;&lt; &quot;`\n&quot;; str = s;};
  Field&lt;string&gt; quoted( quoted_getter, quoted_setter); 
  quoted = string{&quot;Rust&quot;};
  cout &lt;&lt; string{quoted} &lt;&lt; endl;
}
// output:
//modified from `default` to `Rust`
//`Rust`
</code></pre>
<p>当然这里有个问题，<code>using Setter = std::function&lt;void(const T &amp;)&gt;;</code>固定了了<code>Setter</code>的形参类型，我们甚至没有机会去重载一个<code>void(T &amp;&amp;)</code>版本的<code>Setter</code>用来区分实参的值类型</p>
<p>嗯，在<code>C++</code>里左右值引用是不同的变量类型，而在有<code>GC</code>的<code>C#</code>上，引用并无左右引用而言</p>
<p>所以具体地，在<code>main()</code>第<code>6</code>行，我们向<code>Field&lt;string&gt;::operator=(const string&amp;)</code>传入了纯右值<code>string{&quot;Rust&quot;}</code>，但函数内部不知情，不能移动<code>string</code>来节省开销</p>
<p>所以接下来把<code>Setter/Getter</code>类型而不是被代理的类型<code>T</code>作为模板参数</p>
<p><strong>第2版代码:</strong></p>
<pre><code class="language-c++">template&lt;typename Getter, typename Setter&gt;
class Field {
    Getter _get;
    Setter _set;
    using GetterResT = std::invoke_result_t&lt;Getter&gt;;
public:
    explicit Field(
            Getter getter = {},
            Setter setter = {}
    ) : _get{getter}, _set{setter} {}

    GetterResT get() { return _get(); }
    operator GetterResT() { return _get(); }

    template&lt;typename Arg&gt;
    Field &amp;operator=(Arg &amp;&amp;arg) {
        _set(std::forward&lt;Arg&gt;(arg));
        return *this;
    }
};
</code></pre>
<p>其中</p>
<ol>
<li>使用<code>std::invoke_result_t&lt;Getter&gt;</code>获取<code>_get()</code>返回值的类型</li>
<li><code>operator=</code>修改为模板函数，可以同时处理左右值了</li>
</ol>
<p>在函数体中的使用：</p>
<pre><code class="language-c++">int main() {
  string str = &quot;default&quot;;
  auto quoted_getter = [&amp;]( ) { return &quot;`&quot; + str + &quot;`&quot;; };
  auto quoted_setter = [&amp;](auto &amp;&amp;s){ 
    cout &lt;&lt; &quot;modified from `&quot; &lt;&lt; str &lt;&lt; &quot;` to `&quot; &lt;&lt; s &lt;&lt; &quot;`\n&quot;; 
    str = std::forward&lt;decltype(s)&gt;(s);
    };
  Field quoted( quoted_getter, quoted_setter); 
  quoted = string{&quot;Rust&quot;};
  cout &lt;&lt; string{quoted} &lt;&lt; endl;
}
// output:
//modified from `default` to `Rust`
//`Rust`
</code></pre>
<p>注意这里<code>setter</code>(<code>_set</code>)如果需要的话，定义为一个模板函数来处理左右值</p>
<p>..完成一半了，接下来考虑<code>Field</code>作为类中成员变量如何使用</p>
<p>继续使用<code>lambda</code>作为<code>getter/setter</code>就不太可行了</p>
<p>因为定义类时要写明<code>Getter/Setter</code>类别，但我们拿不到<code>lambda</code>类型</p>
<p>因此改用具名的函数对象来捕获<code>this</code>指针</p>
<p><code>InlineCode</code>类在<code>C++</code>中可以实现如下</p>
<pre><code class="language-c++">struct InlineCode {
private:
    std::string _text;
    struct TextGetter {
        InlineCode *self;
        std::string operator()() {
            return &quot;`&quot; + self-&gt;_text + &quot;`&quot;;
        }
    }  ;
    struct TextSetter {
        InlineCode *self;
        template&lt;typename Str&gt;
        void operator()(Str &amp;&amp;s) {
            cout &lt;&lt; &quot;modified from `&quot; &lt;&lt; self-&gt;_text &lt;&lt; &quot;` to `&quot; &lt;&lt; s &lt;&lt; &quot;`\n&quot;;
            self-&gt;_text = std::forward&lt;decltype(s)&gt;(s);;
        }
    };
public:
    Field&lt;TextGetter, TextSetter&gt; text;
    InlineCode(): _text{}, text{{this}, {this}}{}
};
</code></pre>
<p>使用：</p>
<pre><code class="language-c++">InlineCode code;
code.text = string{&quot;Rust&quot;};
cout &lt;&lt; string{code.text} &lt;&lt; endl;
</code></pre>
<p>看起来类的命名因为<code>Getter/Setter</code>的后缀有些乱了，那再举一个栗子优化下代码结构</p>
<p>假设类型<code>SomeClass</code>有一个属性<code>time</code>，<code>getter</code>返回带前缀的时间<code>string</code>，<code>setter</code>接收时间<code>string</code>或<code>UNIX</code>时间戳（<code>long long</code>)</p>
<p>实现如下</p>
<pre><code class="language-c++">template&lt;typename T&gt; using FieldAs = Field&lt;typename T::Getter, typename T::Setter&gt;;struct SomeClass {
    std::string _time;
    struct Time {
        struct Getter {
            SomeClass *self;
            std::string operator()() {
                return string{&quot;time here is &quot;} + self-&gt;_time;
            }
        };
        struct Setter {
            SomeClass *self;
            template&lt;typename Arg&gt;
            void operator()(Arg &amp;&amp;arg) {
                using ValT = std::decay_t&lt;Arg&gt;;
                if constexpr (std::is_convertible_v&lt;ValT, std::string_view&gt;)
                    self-&gt;_time = std::forward&lt;Arg&gt;(arg);
                else {
                    std::tm *tm = std::localtime(&amp;arg);
                    std::stringstream ss;
                    ss &lt;&lt; std::put_time(tm, &quot;%Y-%m-%d %H:%M:%S&quot;);
                    self-&gt;_time = ss.str();
                }
            }
        };
    };
    FieldAs&lt;Time&gt; time;
    SomeClass() : time{{this},
                       {this}} {};
}; 
</code></pre>
<p>首先我们定义一个模板别名</p>
<pre><code class="language-c++">template&lt;typename T&gt; using FieldAs = Field&lt;typename T::Getter, typename T::Setter&gt;;
</code></pre>
<p>这样我们先在<code>SomeClass</code>内部定义属性对应的类型<code>Time</code>，<code>Time</code>内部再定义<code>Getter/Setter</code>类型，最后使用<code> FieldAs&lt;Time&gt;</code>定义成员变量就行，这样命名更顺眼一点</p>
<p>使用:</p>
<pre><code class="language-c++">int main() {
    SomeClass that;
    that.time = &quot;2023-10-02&quot;;
    cout &lt;&lt; string{that.time} &lt;&lt; endl;
    that.time = std::int64_t{1696232071};
    cout &lt;&lt; string{that.time} &lt;&lt; endl;
}
// output:
//time here is 2023-10-02
//time here is 2023-10-02 15:34:31
</code></pre>
<p><code>Full code:</code></p>
<p><a href="https://gist.github.com/zixfy/c83955d511ebe1814b3dc1cd8422b87e">Github Gist</a></p>
<p>当然我认为使用<code>Properties</code>模式时，<code>Getter</code>和<code>Setter</code>内部逻辑不能太复杂，否则整体代码可读性太差</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DML-BDI实验室指北]]></title>
        <id>http://zixfy.github.io/post/dml-bdi-shi-yan-shi-zhi-bei/</id>
        <link href="http://zixfy.github.io/post/dml-bdi-shi-yan-shi-zhi-bei/">
        </link>
        <updated>2023-10-07T05:56:51.000Z</updated>
        <summary type="html"><![CDATA[<center><b>#只身打马过草原</b></center>
<p>（本站图床托管于<code>Github</code>，大概率会被屏蔽）</p>
]]></summary>
        <content type="html"><![CDATA[<center><b>#只身打马过草原</b></center>
<p>（本站图床托管于<code>Github</code>，大概率会被屏蔽）</p>
<!-- more -->
<p><strong>Acknowledgement:</strong></p>
<p><a href="https://liyirui-git.github.io/tech/%E6%8A%98%E8%85%BE/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html">liyirui-git.github.io</a></p>
<p><a href="https://jingtao.fun/posts/5cce79bf/">jingtao.fun</a></p>
<h3 id="ssh">SSH</h3>
<h4 id="ssh软件">SSH软件</h4>
<ul>
<li>类Unix: <code>shell</code>内的<code>ssh</code>命令</li>
<li>Windows: <code>cmd</code>内的<code>ssh</code>命令（win10/11自带<code>openssh</code>），或<code>WindowsTerminal</code>/<code>Putty</code>/<code>Xshell</code>/<code>WSL</code>等软件，选个好看的</li>
<li>Android:华为云等软件</li>
<li>maxOS/iOS:<code>iTerm2</code>，<code>xTerm256</code>, <code>Termius</code>, <code>Koder</code>等软件</li>
</ul>
<h4 id="公钥免密登录">公钥免密登录</h4>
<ol>
<li>（401服务器<code>ssh</code>密码方式登录已禁用，2023.3）</li>
<li>看<code>cat ~/.ssh/id_rsa.pub</code>(<code>type \path\to\windows-user\.ssh\id_rsa.pub</code>)是否存在，没有使用<code>ssh-keygen</code>命令生成公钥</li>
<li>让管理员将<code>id_rsa.pub</code>中内容追加到<code>gaia.buaadml.info:/home/myUserName/.ssh/authorized_keys</code>中以免密登录</li>
<li>修改用户密码:<code>ldap</code>管理员后台</li>
</ol>
<p><strong>注意</strong>，无法<code>ssh</code>登录时，请在<code>ssh</code>末尾追加<code>-v</code>选项，将报错信息发送而给<code>admin</code></p>
<h3 id="nfs">NFS</h3>
<h4 id="网络文件系统">网络文件系统</h4>
<ul>
<li>简单地说，<code>gaia</code>上<code>/home</code>目录挂载的是物理磁盘，计算节点上<code>/home</code>目录是通过<code>NFS</code>文件协议用<code>TCP</code>同步共享<code>gaia.buaadml.info:/home</code>的，因此高<code>I/O</code>，低计算的任务，如下载，请尽量使用gaia机器</li>
<li><code>NFS</code>没设<code>intr</code>选项(2023.3)，所以理论上切换目录无限等待且不能<code>Ctrl^C</code>中断(<code>SIGINT</code>)可能是<code>NFS</code>问题（我个人在别的服务器上见过这种情况）</li>
</ul>
<pre><code class="language-bash">(base) zhaozixuan at gaia in ~  
$ mount | grep '/dev/sd'
#/dev/sda2 on / type ext4 (rw,relatime,data=ordered)
#/dev/sda1 on /boot/efi type vfat (rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=iso8859-1,shortname=mixed,errors=remount-ro)
#/dev/sdb on /home type ext4 (rw,relatime,stripe=64,data=ordered)
</code></pre>
<pre><code class="language-bash">(base) zhaozixuan at jack in ~    
$ mount | grep '/home'
#buaadml.info:/ on /home type nfs4 (rw,relatime,vers=4.0,rsize=8192,wsize=8192,namlen=255,hard,proto=tcp,port=2041,timeo=14,retrans=2,sec=sys,clientaddr=10.134.139.116,local_lock=none,addr=10.134.138.250,_netdev)
</code></pre>
<h4 id="更多参考">更多参考</h4>
<p><a href="http://cn.linux.vbird.org/linux_server/0330nfs_1.php">鸟哥的 Linux 私房菜 -- NFS 服务器</a></p>
<h3 id="file-transfer">File Transfer</h3>
<h4 id="命令行">命令行</h4>
<ul>
<li><code>wget</code>:通过url下载文件</li>
<li><code>scp</code>/<code>rsync</code>:个人机器/实验室服务器互传文件目录</li>
<li><code>curl</code>:http报文</li>
</ul>
<h4 id="sftp协议软件推荐">sftp协议软件（推荐）</h4>
<p>推荐根据自己的<code>IDE</code>,如<code>VSCode</code>,<code>JetBrains</code>系（自带）,安装可视化<code>sftp</code>插件管理服务器文件</p>
<h3 id="linux-command">Linux Command</h3>
<pre><code class="language-bash">1. man COMMAND / COMMAND -h/ COMMAND --help
# 查看某一命令COMMAND之说明
2. Ctrl^C
# 向进程发送SIGINT
3. Ctrl^D
# 退出shell/退出su切换到的用户/断开ssh
4. Ctrl^Z
# 挂起命令进程，jobs查看挂起进程
5. cd -
# 返回上次访问目录
6. grep &quot;mykeyword&quot;
# 查找关键字 
7. history | tail -n 50
# 最后50条历史命令 
8. alias
#为命令起别名，如 
alias jack='ssh zhaozixuan@jack.buaadml.info'
9. alias
# 覆写命令对应程序的绝对路径，如 
alias cmake='/path/to/my/own/cmake'
#但不建议alias python='/usr/bin/python3'，因为alias python可能会覆盖conda虚拟环境的python
10. chomd [-r]/ chown
# 更改文件（目录）权限（归属用户/用户组）
11. tail [-f] [-n &lt;number&gt;]
# 查看文件最后&lt;number&gt;行，-f为实时刷新，适合查看志记文件
12. which COMMAND
# 查看命令对应程序位置， 如which pip3, which python
</code></pre>
<h4 id="文件权限与chmod">文件权限与chmod</h4>
<p><a href="https://www.runoob.com/linux/linux-comm-chmod.html">link</a></p>
<h4 id="更多参考-2">更多参考</h4>
<p><a href="https://www.man7.org/linux/man-pages/">man-page</a>, <a href="https://book.douban.com/subject/35933905/">Linux命令行与shell脚本编程大全（第4版）</a></p>
<h3 id="vim">Vim</h3>
<p><code>vim</code>三模式：一般模式，命令行模式，编辑模式，使用<code>vi/vim</code>进入文件时是一般模式</p>
<h4 id="编辑模式">编辑模式</h4>
<p>一般模式下，进入编辑模式</p>
<p><code>i</code>   光标前插入</p>
<p><code>a</code>    光标后插入</p>
<p><code>o</code>    光标下一行插入</p>
<h4 id="命令行模式">命令行模式</h4>
<p>一般模式下，进入命令行模式：<code>:</code>, <code>/</code></p>
<p><code>:num</code> 跳至第<code>num</code>行，<code>num=&quot;$&quot;</code>时跳至文件尾</p>
<p><code>:set filetype=c</code> 代码文件后缀与语言不一致时显式指引<code>vim</code>进行正确的语法高亮</p>
<p><code>:q</code>  退出 <code>vi</code></p>
<p><code>:q!</code>  强制退出，不保存文件</p>
<p><code>:wq</code>  保存文件并退出</p>
<p><code>/str</code>  从光标处向文件尾部搜索，查找 <code>&quot;str&quot;</code> 字符串，<code>n</code>/<code>N</code> 查看下/上一个位置</p>
<p><code>?str</code>  从光标处向文件首部搜索，查找 <code>&quot;str&quot;</code> 字符串，<code>n</code>/<code>N</code>查看下/上一个位置</p>
<p><code>:s/str1/str2/g</code>  将当前行中所有的 <code>&quot;str1&quot;</code>，均用 <code>&quot;str2&quot;</code> 替换</p>
<p><code>:s/str1/str2/gc</code>  将当前行中所有的 <code>&quot;str1&quot;</code>，均用 <code>&quot;str2&quot;</code> 替换， 替换时需要确认</p>
<p><code>:%s/str1/str2/g</code>  将文件中所有的  <code>&quot;str1&quot;</code>，均用 <code>&quot;str2&quot;</code> 替换</p>
<p><code>:%s/str1/str2/gc</code>  将文件中所有的  <code>&quot;str1&quot;</code>，均用 <code>&quot;str2&quot;</code> 替换，替换时需要确认</p>
<h4 id="一般模式">一般模式</h4>
<p>其他模式下，进入命令行模式：<code>Esc</code></p>
<p><code>gg</code>  光标移动到文档头部</p>
<p><code>G</code>  光标移动到文档尾部</p>
<p><code>ngg</code>  光标移动到第 <code>n</code> 行头部</p>
<p><code>n+</code>  光标向下移动 <code>n</code> 行</p>
<p><code>n-</code>  光标向上移动 <code>n</code> 行</p>
<p><code>0</code>  光标移动到当前行行首</p>
<p><code>$</code>  光标移动到当前行行尾</p>
<p><code>w</code>  光标移动到下一个字的开头</p>
<p><code>b</code>  光标移动到上一个字的开头</p>
<p><code>fx</code>  光标移动到 当前行下一个字母<code>x</code>的位置</p>
<p><code>yy</code>  复制当前行（<code>Vim</code>内部剪贴板）</p>
<p><code>nyy</code>  复制当前行及下面的 <code>n-1</code> 行</p>
<p><code>p</code>  粘贴（<code>Vim</code>内部剪贴板）</p>
<p><code>x</code>  删除光标后一个字符</p>
<p><code>X</code>  删除光标前一个字符</p>
<p><code>nx</code>  删除光标后 <code>n</code> 个字符</p>
<p><code>nX</code>  删除光标前 <code>n</code> 个字符</p>
<p><code>d0</code>  从光标处删到行首</p>
<p><code>d$</code>  从光标处删到行尾</p>
<p><code>dd</code>  删除光标所在行</p>
<p><code>ndd</code>  删除光标所在行及其后 <code>n-1</code> 行</p>
<p><code>u</code>  撤销一步操作</p>
<p><code>v</code> <code>visual</code>模式，相当于鼠标拖动选取之操作，选择完后<code>y</code>复制,<code>x</code>剪切</p>
<h4 id="vim-配置文件">Vim 配置文件</h4>
<p><code>bashvim ~/.vimrc</code><br>
追加：</p>
<pre><code class="language-bash">syntax enable #开启语法高亮
set nu #开启行号显示
#set compatible 平等对待Vi/Vim指令
# 或者
#set nocompatible 不与 Vi 兼容（采用 Vim 自己的操作命令）。
set showmode #显示当前模式
set showcmd #命令行模式下显示键入的命令
#set shiftwidth=4
#set softtabstop=4 缩进设置，自行了解
set cursorline #高亮显示当前行
set ruler #显示光标
set showmatch #左右匹配括号高亮
set incsearch #启用'/'命令行模式的增量搜索，也就是每键入一个字符都会重新搜索字符串，通常可以更快搜索到结果
set mouse=a #开启鼠标控制（滚轮与鼠标控制`visual`模式的选取）
#...e.t.c.
</code></pre>
<p>刷新配置：重启<code>vim</code>进程，或命令行模式下<code>:source ~/.vimrc</code></p>
<p>注意：以上每行配置都可在<code>:</code>命令模式下对当前文件设置，设置仅对当前打开文件对应的<code>vim</code>进程有效</p>
<h4 id="vim-in-ide">Vim in IDE</h4>
<p><code>JetBrains</code>系<code>IDE</code>的官方维护的<code>vim</code>插件：<a href="https://plugins.jetbrains.com/plugin/164-ideavim">ideaVim</a>，<code>keymap</code>中设置<code>Pulgin -&gt; IdeaVim -&gt; Vim</code>快捷键快速启用/关闭<code>vim</code>，有效集合了<code>vim</code>和<code>GUI</code>的优点</p>
<h3 id="shell">SHELL</h3>
<h4 id="bashzshfishetc">bash/zsh/fish/etc...</h4>
<p><code>shell</code>就是<code>ssh</code>登上去的黑框框，这个与我们交互的进程通常默认是<code>bash</code>，<code>zsh</code>是另一种交互式终端，但在使用上基本与<code>bash</code>无区别，优点在于完善，高度可定制的插件机制，用来提高我们的效率。为了减少烦人的敲<code>shell</code>命令的时间，一些插件如自动补全与高亮是必要的，但<code>shell</code>的配置/插件修改比较麻烦，<code>zsh</code>的<code>oh-my-zsh</code>框架可以大大简化这个过程</p>
<h4 id="zsh-oh-my-zsh推荐">zsh &amp; oh-my-zsh（推荐）</h4>
<p>以<code>oh-my-zsh</code>添加自动补全与语法高亮这两个常用插件为例</p>
<pre><code class="language-bash">#1.进入zsh 
zsh
#2.安装oh-my-zsh
git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh
cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc
vim ~/.zshrc, &quot;ZSH_THEME=...&quot; #这一行可以自己修改成好看点的主题
#3.插件安装
cd ~/.oh-my-zsh/custom/plugins
git clone https://github.com/zsh-users/zsh-autosuggestions.git
git clone https://github.com/zsh-users/zsh-syntax-highlighting.git
vim ~/.zshrc #修改插件列表，plugins变量：plugins=(git zsh-autosuggestions zsh-syntax-highlighting)
source ~/.zshr #刷新配置
</code></pre>
<p>应该有补全效果了(按右箭头补全)</p>
<h4 id="prompt修改">PROMPT修改</h4>
<p><code>PROMPT</code>指的是每次<code>shell</code>等待输入时打印的信息，<code>oh-my-zsh</code>是高度定制的，以最简单的<code>PROMPT</code>修改为例</p>
<p>1.显示<code>conda</code>环境名，直接使用<code>conda</code>之命令行</p>
<pre><code class="language-bash">conda init zsh
</code></pre>
<p>2.以<code>steeef</code>主题为例添加一个实时时间显示为例</p>
<pre><code class="language-bash">vim ~/.zshrc
</code></pre>
<h4 id="修改zsh_themesteeef">修改ZSH_THEME=&quot;steeef&quot;</h4>
<p><code>bashvim ~/.oh-my-zsh/themes/steeef.zsh-theme</code></p>
<pre><code class="language-bash">#追加
if [[ $terminfo[colors] -ge 256 ]]; then
    turquoise=&quot;%F{81}&quot;
    orange=&quot;%F{166}&quot;
    purple=&quot;%F{135}&quot;
    hotpink=&quot;%F{161}&quot;
    limegreen=&quot;%F{118}&quot;
    violet=&quot;%F{205}&quot;
    darkorange=&quot;%F{208}&quot;
    cyan=&quot;%F{51}&quot;
else
    turquoise=&quot;%F{cyan}&quot;
    orange=&quot;%F{yellow}&quot;
    purple=&quot;%F{magenta}&quot;
    hotpink=&quot;%F{red}&quot;
    limegreen=&quot;%F{green}&quot;
    violet=&quot;%F{violet}&quot;
    darkorange=&quot;%F{darkorange}&quot;
    cyan=&quot;%F{cyan}&quot;
fi
#修改PROMPT
PROMPT=$'%{$darkorange%}%n${PR_RST} at %{$violet%}%m${PR_RST} in %{$cyan%}%~${PR_RST} $vcs_info_msg_0_$(virtualenv_info)    %{$FG[040]%}%D{%Y/%m/%d} - %*%{$reset_color%}
$ '
</code></pre>
<p>以上操作修改了<code>PROMPT</code>的颜色，添加了当前时间</p>
<pre><code class="language-bash">vim ~/.zshrc
#追加
TMOUT=1
TRAPALRM () 
{ zle reset-prompt }
</code></pre>
<p>以上操作使得<code>PROMPT</code>每秒刷新一次，以显示实时时间</p>
<pre><code class="language-bash">source ~/.zshrc
</code></pre>
<p>刷新配置后生效</p>
<p>当然也有其他很多主题，如<code>powerline10k</code>， <code>random</code>，注意，你的终端需要支持主题相关的<strong>字体与彩显</strong>，否则会有显示上的错误</p>
<h4 id="修改默认shell">修改默认SHELL</h4>
<ul>
<li>现有账户默认<code>shell</code>均为<code>bash</code>（2023.3）</li>
<li>在<code>~/.profile</code>追加启动指定<code>shell</code>的命令并没有真正改变默认<code>shell</code>，而是在启动<code>bash</code>时自动执行一条进入指定<code>shell</code>的命令，例如此时<code>exit</code>将回到<code>bash</code>，而不是关闭<code>shell</code></li>
<li><code>chsh</code>/<code>usermode</code>指令并不能修改默认<code>shell</code>，因为大家的<code>linux</code>系统账户不是在节点机器本地管理，而是通过<code>VM chaos</code>提供的<code>ldap</code>协议服务管理，因此需要联系管理员在<code>chaos</code>之<code>phpLDAPadmin</code>上修改默认<code>shell</code>启动路径</li>
</ul>
<h3 id="windows-subsystem-for-linux">Windows Subsystem for Linux</h3>
<p>不喜欢Win的<code>cmd</code>就装个<code>wsl</code>吧，比虚拟机软件更轻量，且自然地共存，可无缝切换的双系统方案</p>
<h4 id="wsl10">WSL1.0</h4>
<p>没有使用真正的<code>Linux</code>内核，实际是把<code>Linux</code>内核的系统调用转换成<code>Win</code>的系统调用</p>
<p>（所以慎重选择<code>WSL1.0</code>作为开发用环境）</p>
<h4 id="wsl20">WSL2.0</h4>
<p><code>Hyper-V</code>硬件虚拟化实现<code>Linux</code>内核，可以简单理解为虚拟机</p>
<h4 id="wsl网络">WSL网络</h4>
<p><a href="https://learn.microsoft.com/zh-cn/windows/wsl/networking">link</a></p>
<h4 id="wsl桌面">WSL桌面</h4>
<p><em>Note: this section is a copy of <a href="https://liyirui-git.github.io/tech/%E6%8A%98%E8%85%BE/WSL+Linux%E5%8F%AF%E8%A7%86%E5%8C%96%E7%95%8C%E9%9D%A2.html">https://liyirui-git.github.io/</a></em></p>
<ol>
<li>准备工作</li>
</ol>
<p>我使用的是<code>Windows</code>应用商店中的<code>Ubuntu 18.04 LTS</code>，安装完成以后，为了提高软件包下载速度，一般是要把软件库更换成清华开源镜像：<code>Ubuntu</code>清华开源镜像。</p>
<p>更换好以后，先执行下面的命令，更新<code>apt</code>：</p>
<pre><code class="language-bash">$ sudo apt update
$ sudo apt upgrade
</code></pre>
<ol>
<li>安装图形化界面<br>
这里使用的是<code>xfce4</code>，安装命令为：</li>
</ol>
<pre><code class="language-bash">$ sudo apt install xfce4
</code></pre>
<p>它的优点主要是占用空间小，此外该界面主要是有一个图形界面可以使用<code>spacemacs</code>。</p>
<p>然后安装<code>xrdp</code>：</p>
<pre><code class="language-bash">$ sudo apt install xrdp
</code></pre>
<ol start="2">
<li>软件配置<br>
配置<code>xrdp</code>端口</li>
</ol>
<pre><code class="language-bash">$ sudo sed -i 's/port=3389/port=3390/g' /etc/xrdp/xrdp.ini
</code></pre>
<p>端口号要记住，后面从<code>windows</code>进行连接的时候要用到。这里面 <code>3389</code> 是默认配置，这里将其改为 <code>3390</code> 是避免和 <code>windows</code> 的端口冲突。因为两边的端口号是通的，在 <code>wsl</code> 中开一个 <code>8080</code> 端口的 <code>WebServer</code>，在 <code>windows</code> 可以直接访问。</p>
<p>配置<code>xsession</code></p>
<pre><code class="language-bash">$ sudo echo xfce4-session &gt;~/.xsession
#这一步其实是在告诉系统，开启桌面环境的时候开启什么桌面环境。
</code></pre>
<p>启动 <code>xrdp</code></p>
<pre><code class="language-bash">$ sudo service xrdp restart
</code></pre>
<ol start="3">
<li><code>Windows</code>远程连接<br>
打开<code>Windows</code>中的“远程桌面连接” （快捷方式是 <code>win+r</code> 输入<code>“mstsc”</code>）</li>
</ol>
<p>在计算机名的地方输入本地的<code>3390</code>端口，用户名输入<code>root</code>，如下图：</p>
 <img src="https://liyirui-git.github.io/tech/%E6%8A%98%E8%85%BE/WSL+Linux%E5%8F%AF%E8%A7%86%E5%8C%96%E7%95%8C%E9%9D%A2.assets/image-20200809160433004.png" style="zoom:50%;" />
<p>进入以后会显示一个小的对话框：</p>
<figure data-type="image" tabindex="1"><img src="https://liyirui-git.github.io/tech/%E6%8A%98%E8%85%BE/WSL+Linux%E5%8F%AF%E8%A7%86%E5%8C%96%E7%95%8C%E9%9D%A2.assets/image-20200809161018388.png" alt="" loading="lazy"></figure>
<p>这个时候点击“ok”，会弹出填写用户名和密码的对话框，填写对应的用户名和密码：</p>
<figure data-type="image" tabindex="2"><img src="https://liyirui-git.github.io/tech/%E6%8A%98%E8%85%BE/WSL+Linux%E5%8F%AF%E8%A7%86%E5%8C%96%E7%95%8C%E9%9D%A2.assets/image-20200809161159946.png" alt="" loading="lazy"></figure>
<p>点击OK即可登录到可视化界面：</p>
<figure data-type="image" tabindex="3"><img src="https://liyirui-git.github.io/tech/%E6%8A%98%E8%85%BE/WSL+Linux%E5%8F%AF%E8%A7%86%E5%8C%96%E7%95%8C%E9%9D%A2.assets/20190621201436773.png" alt="" loading="lazy"></figure>
<p>如果WSL的Ubuntu系统关闭，如关机重启，会导致远程连接不上，此时需要先在Win10中打开Ubuntu的命令行界面，输入：</p>
<pre><code class="language-bash">$ sudo service xrdp restart
</code></pre>
<p>此时再远程连接，即可连接上。</p>
<figure data-type="image" tabindex="4"><img src="https://liyirui-git.github.io/tech/%E6%8A%98%E8%85%BE/WSL+Linux%E5%8F%AF%E8%A7%86%E5%8C%96%E7%95%8C%E9%9D%A2.assets/762700-20171116183439656-1751821230.png" alt="" loading="lazy"></figure>
<ol start="4">
<li>尾声<br>
后续还看到一个特别牛批的大神做的：<code>WSL</code>使用小结：<a href="https://www.cnblogs.com/wurui1994/p/7839777.html">从ArchLinux到Manjaro</a>，以及知乎的问题：<a href="https://www.zhihu.com/question/355179099">Deepin Linux上架WSL要多久?</a>，<a href="https://zhuanlan.zhihu.com/p/51270874">知乎文章：利用WSL打造Arch开发环境</a></li>
</ol>
<p>后续可以继续折腾。</p>
<p><em>Note: End of the copy</em></p>
<h3 id="windows-terminal">Windows Terminal</h3>
<p>微软官方的终端软件：<a href="https://learn.microsoft.com/zh-cn/windows/terminal/install">link</a></p>
<p><code>Windows Terminal</code>相比于<code>cmd</code>:1.好看 2.整合<code>cmd</code>/<code>powerShell</code>/<code>WSL</code>/<code>git bash</code>等需要终端显示的场景，集中终端配置</p>
<h4 id="以windows-terminal配置sshwsl发起为例">以Windows Terminal配置ssh（WSL发起）为例</h4>
<ul>
<li>安装<code>wsl</code>与<code>Windows Terminal</code>，记不太清了，但好像<code>Windows Terminal</code>会自动检测<code>WSL</code>并为其生成默认配置文件</li>
<li><code>Windows Terminal -&gt; Settings</code>，从<code>WSL</code>的配置文件复制一份配置文件，修改<code>Command line</code>，追加进行<code>ssh</code>连接的命令（注意，这里的命令大概是在<code>shell</code>配置文件之前执行的，因此不要依赖<code>~/.bashrc</code>或<code>~/.zshrc</code>创建的环境变量）</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://raw.githubusercontent.com/zixfy/imageshack2023/main/img/20230610222226.png" alt="" loading="lazy"></figure>
<h3 id="tmux推荐">Tmux（推荐）</h3>
<p><code>ssh</code>默认长时间不操作会断开，为了防止耗时操作中<code>ssh</code>终端断开，可以修改<code>/etc/ssh/ssh_config</code>定时向服务器发报文保活，或者使用<code>autossh</code>等软件</p>
<p>不过更推荐<code>Tmux</code>，<code>Tmux</code>是在服务器本地创建多个<code>shell</code>交互界面，所以不受<code>ssh</code>连接生命期之影响，可以挂在后台，不用担心<code>ssh</code>断了或者卡死<code>shell</code>就中断了导致前台进程挂掉，而且可以灵活切换多个<code>SHELL</code>界面</p>
<p><code>Tmux</code>中两个主要概念是<code>sessions</code>与<code>windows</code>，简单地说，可以对应于<strong>带图形用户界面的操作系统</strong>中的<strong>桌面</strong>与<strong>应用窗口</strong>，一个<code>windows</code>对应一个<code>shell</code>进程，一个<code>sessions</code>持有一个或多个<code>windows</code>。</p>
<p>使用<code>tmux</code>指令将新建一个<code>session</code>，<code>tmux rename mySessionName</code>（在当前<code>session</code>下）将为<code>session</code>命名，不然默认就是数字序号。进入<code>tmux</code>后按一次<code>Ctrl^B</code>进入命令模式，<code>Ctrl^B</code>后按<code>D</code>键将当前<code>session</code> <code>detach</code>掉，也就是挂在后台，这将退回到原来的<code>shell</code>（<strong>注意</strong>，<code>tmux</code>创建的<code>shell</code>中使用<code>exit</code>或<code>Ctrl^D</code>仍然将杀死<code>shell</code>，而不是把他挂在后台运行）。使用<code>tmux ls</code>看当前所有<code>session</code>，使用<code>tmux a -t mySessionName</code>回到<code>session</code>，使用<code>tmux kill-session -t mySessionName</code>关闭后台<code>session</code>，也可以进入<code>tmux session</code>后 <code>Ctrl^B</code>后按<code>S</code>查看所有<code>session</code>，并可以选择切换</p>
<p><code>tmux session</code>中，默认只有一个全屏的<code>window</code>，<code>Ctrl^B</code>接<code>%</code>把当前<code>window</code>左右分割成两个<code>window</code>，<code>Ctrl^B</code>接&quot;把当前<code>window</code>上下分割，<code>Ctrl^B</code>接方向键切换聚焦的<code>window</code>，<code>Ctrl^B</code>接<code>Ctrl^方向键</code>调整<code>window</code>尺寸</p>
<p><code>Ctrl^B</code>接<code>[</code>可以上下滚动<code>shell</code>输出</p>
<figure data-type="image" tabindex="6"><img src="https://raw.githubusercontent.com/zixfy/imageshack2023/main/img/20230610222244.png" alt="" loading="lazy"></figure>
<p>对tmux进行设置</p>
<ul>
<li>生成配置文件 <code>vim ~/.tmux.conf</code></li>
<li>写入内容</li>
</ul>
<pre><code class="language-bash">set -g default-terminal &quot;screen-256color&quot;
# 开启xTerm256彩色显示
set -g default-shell /bin/zsh
# 设置默认SHELL
set-option -g mouse on
# 开启鼠标控制
</code></pre>
<ul>
<li>注意：鼠标控制的<code>tmux</code>下，按住<code>shift</code>以鼠标框选，<code>Ctrl^shift^c/v</code>以复制粘贴</li>
<li>配置可热修改，使用<code>tmux source-file ~/.tmux.conf</code>生效配置</li>
</ul>
<h4 id="更多参考-3">更多参考</h4>
<p><code>man tmux</code> or <a href="https://www.man7.org/linux/man-pages/man1/tmux.1.html">link</a></p>
<h3 id="screen">Screen</h3>
<p>类似的终端复用器还有 <code>GNU Screen</code>。<code>Tmux</code> 与它功能相似，但是通常来说<code>Tmux</code>更易用，也更强大。</p>
<p><em>Note: This section is a copy of <a href="https://liyirui-git.github.io/tech/%E6%8A%98%E8%85%BE/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html"> yirui的实验室服务器使用指南</a></em></p>
<h4 id="screen基础">Screen基础</h4>
<p>可以通过创建一个屏幕来实现后台运行，新建一个屏幕的命令是：</p>
<pre><code class="language-bash">$ screen -S [screen-name]  
</code></pre>
<p>查看当前所有屏幕的列表的命令是：</p>
<pre><code class="language-bash">$ screen -ls
</code></pre>
<p>进入某一个屏幕的命令是：</p>
<pre><code>bash$ screen -r [screen-name]
</code></pre>
<p>kill一个屏幕的命令是在该屏幕中输入：</p>
<pre><code class="language-bash">$ exit
</code></pre>
<p>Screen退出当前窗口但不杀死<br>
<code>ctrl + a + d</code> 这一操作也叫<code>detached</code></p>
<p><code>Screen</code>杀死会话窗口<br>
如果想关掉一个多余的窗口，有3种方法：</p>
<p><code>kill -9 threadnum </code>例如在上面的2637，<code>kill -9 2637</code> 即可杀死线程，当然就杀死了窗口</p>
<p>使用<code>Ctrl a +k</code> 杀死当前窗口和窗口中运行的程序</p>
<p>使用<code>Ctrl a</code> 然后输入<code>quit</code>命令退出<code>Screen</code>会话。需要注意的是，这样退出会杀死所有窗口并退出其中运行的所有程序</p>
<p><code>Screen</code>清除死去的窗口<br>
当窗口被杀死后，再用<code>screen -ls</code> 可以看到该窗口后面的(???dead)字样，说明窗口死了，但是仍在占用空间。这时需要清除窗口</p>
<pre><code class="language-bash">$ screen -wipe #自动清除死去的窗口
</code></pre>
<p>这样的窗明几净了~</p>
<p><code>Screen</code>意外掉线重连<br>
有的时候，意外断开连接，再次进入某个screen会出现以下报错：</p>
<pre><code class="language-bash">(base) xxxx@i:~$ screen -r fastreid
There is a screen on:
        3157.fastreid   (2021年02月19日 15时19分14秒)   (Attached)
There is no screen to be resumed matching fastreid.
</code></pre>
<p>这个时候是因为它认为还有人在与screen连接，所以连接不上，这个时候，可以通过下面的命令，让screen与之前的连接断开，然后我们再连进去</p>
<pre><code class="language-bash">$ screen -D -r fastreid
</code></pre>
<p>如何记录<code>screen</code>屏幕日志</p>
<p>第一种方法</p>
<p>启动时添加选项<code>-L</code>（Turn on output logging.）会在当前目录下生成<code>screenlog.0</code>文件。</p>
<pre><code class="language-bash">screen -L -dmS test
1
</code></pre>
<p><code>screen -L -dmS test</code>的意思是启动一个开始就处于断开模式的会话，会话的名称是<code>test</code>。<br>
<code>screen -r test</code>连接该会话，在会话中的所有屏幕输出都会记录到<code>screenlog.0</code>文件。</p>
<p>第二种方法</p>
<p>不加选项<code>-L</code>，启动后，在<code>screen session</code>下按<code>ctrl+a H</code>，同样会在当前目录下生成<code>screenlog.0</code>文件。</p>
<p>第一次按下<code>ctrl+a H</code>，屏幕左下角会提示<code>Creating logfile &quot;screenlog.0&quot;.</code>，开始记录日志。<br>
再次按下<code>ctrl+a H</code>，屏幕左下角会提示<code>Logfile &quot;screenlog.0&quot; closed.</code>，停止记录日志。<br>
补充<br>
上面两个方法有个缺点：当创建多个<code>screen</code>会话的时候，每个会话都会记录日志到<code>screenlog.0</code>文件。<code>screenlog.0</code>中的内容就比较混乱了。</p>
<p>解决方法如下，让每个<code>screen</code>会话窗口有单独的日志文件。</p>
<p>在<code>screen</code>配置文件<code>/etc/screenrc</code>最后添加下面一行：</p>
<pre><code class="language-bash">logfile /tmp/screenlog_%t.log
1
</code></pre>
<p><code>%t</code>是指<code>window</code>窗口的名称，对应<code>screen</code>的<code>-t</code>参数。所以我们启动screen的时候要指定窗口的名称，例如：</p>
<pre><code class="language-bash">screen -L -t window1 -dmS test
1
</code></pre>
<p><code>screen -L -t window1 -dmS test</code>的意思是启动test会话，test会话的窗口名称为window1。屏幕日志记录在<code>/tmp/screenlog_window1.log</code>。如果启动的时候不加-L参数，在screen session下按<code>ctrl+a H</code>，日志也会记录在<code>/tmp/screenlog_window1.log</code></p>
<p><strong>注意</strong>，如果写成：<code>logfile ./screenlog_%t.log</code> 则是把日志文件记录到当前目录下。</p>
<p>一个例子</p>
<pre><code class="language-bash">screen -L -t name -S name ./name
1
</code></pre>
<p>第一个name是记录日志的名字<br>
第二个name是<code>screen -ls</code> 列表展示出来的名字<br>
第三个name是需要运行的程序</p>
<p><em>Note: End of the copy</em></p>
<h4 id="更多参考-4">更多参考</h4>
<p><code>man screen</code> or <a href="https://man7.org/linux/man-pages/man1/screen.1.html">link</a></p>
<h3 id="linux-daemon">Linux Daemon</h3>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4777061"><label class="task-list-item-label" for="task-item-4777061"> #TODO</label></li>
</ul>
<h3 id="crontab">crontab</h3>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-2216655"><label class="task-list-item-label" for="task-item-2216655"> #TODO</label></li>
</ul>
<h3 id="gpu">GPU</h3>
<h4 id="nvidia显卡信息查看">Nvidia显卡信息查看</h4>
<pre><code class="language-bash">watch -n 5 'nvidia-smi'
# or
nvidia-smi
</code></pre>
<p>or</p>
<pre><code class="language-bash">watch -n 5 'curl gpu.buaadml.info' 
# or
curl gpu.buaadml.info
# 输出格式参考python第三方库gpustat
# or visit http://gpu.buaadml.info
</code></pre>
<h4 id="显驱与cuda安装卸载">显驱与CUDA安装/卸载</h4>
<p>英伟达显卡驱动 ：告诉计算机识别显卡硬件，调用其计算资源</p>
<p><code>CUDA</code> ：是<code>NVIDIA</code>推出的只能用于<code>Nvidia GPU</code>的并行计算框架, 只有安装这个框架才能够进行复杂的并行计算， 主流的深度学习框架也都是基于<code>CUDA</code>进行<code>GPU</code>并行加速的</p>
<p><code>nvidia-smi</code>查看驱动/<code>CUDA</code>版本：</p>
<pre><code class="language-bash">+-----------------------------------------------------------------------------+
| NVIDIA-SMI 470.42.01    Driver Version: 470.42.01    CUDA Version: 11.4     |
|-------------------------------+----------------------+----------------------+
| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |
| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |
|                               |                      |               MIG M. |
|#########################+###############==+###############==|
|   0  NVIDIA GeForce ...  Off  | 00000000:17:00.0 Off |                  N/A |
| 27%   45C    P0    59W / 250W |      0MiB / 11019MiB |      1%      Default |
|                               |                      |                  N/A |
+-------------------------------+----------------------+----------------------+
|   1  NVIDIA GeForce ...  Off  | 00000000:18:00.0 Off |                  N/A |
| 42%   59C    P0    74W / 250W |      0MiB / 11019MiB |      0%      Default |
|                               |                      |                  N/A |
+-------------------------------+----------------------+----------------------+
|   2  NVIDIA GeForce ...  Off  | 00000000:65:00.0 Off |                  N/A |
| 41%   58C    P0    63W / 250W |      0MiB / 11016MiB |      0%      Default |
|                               |                      |                  N/A |
+-------------------------------+----------------------+----------------------+
</code></pre>
<p>或</p>
<pre><code class="language-bash">(base) zhaozixuan at jack in ~     2023/06/09 - 23:47:11
$ ll /usr/local/cuda* -d
lrwxrwxrwx  1 root root   21 Apr 28 14:56 /usr/local/cuda -&gt; /usr/local/cuda-11.4/
drwxr-xr-x 18 root root 4.0K May  8  2022 /usr/local/cuda-10.1
drwxr-xr-x 18 root root 4.0K Feb 18 13:42 /usr/local/cuda-10.2
drwxr-xr-x 17 root root 4.0K Apr 28 14:59 /usr/local/cuda-11.4 
</code></pre>
<p>一般来说，更新的显卡适配版本更高的<code>CUDA</code>，而<code>CUDA</code>并不能向下兼容所有显驱</p>
<p>因此，在升级<code>CUDA</code>时，如果<code>CUDA</code>版本不能兼容老显驱，则首先卸载驱动</p>
<pre><code class="language-bash">sudo nvidia-uninstall
sudo reboot
</code></pre>
<p>下载<code>Nvidia</code>官方相应<code>CUDA</code>的<code>runfile</code>后</p>
<pre><code class="language-bash">sudo sh /path/to/cuda_&lt;cuda_version&gt;_linux.run
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://raw.githubusercontent.com/zixfy/imageshack2023/main/img/20230610222326.png" alt="" loading="lazy"></figure>
<p>若卸载了老驱动，则勾选安装驱动，其他不需要配置，傻瓜式安装</p>
<h4 id="比特大陆算丰显卡tpu">比特大陆算丰显卡（TPU）</h4>
<p><em>Note: This section is deprecated</em></p>
<h4 id="华为昇腾显卡npu">华为昇腾显卡（NPU）</h4>
<p><code>python</code>运行时库:<code>pyACL</code></p>
<p><a href="https://github.com/zixfy/pyACL-inference">一个推理接口封装</a></p>
<h3 id="conda">CONDA</h3>
<p><code>conda</code>（<code>Anaconda</code>/<code>miniconda</code>）是用于管理虚拟<code>Python</code>环境，以隔离多种<code>Python</code>环境的软件，也是指定虚拟<code>Python</code>环境下包版本管理的软件。<code>Anaconda</code>通过下载运行相应的<code>runfile</code>傻瓜式安装</p>
<p><em>Note: The following is a copy of <a href="https://liyirui-git.github.io/tech/%E6%8A%98%E8%85%BE/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html">yirui的实验室服务器使用指南</a></em></p>
<h4 id="下载anaconda以及环境的搭建">下载Anaconda以及环境的搭建</h4>
<p>主要是要注意怎么把<code>conda</code>命令加入到<code>Ubuntu</code>系统变量中</p>
<p><em>注：<code>conda init &lt;shell_name&gt;</code>, 如<code>conda init zsh</code></em></p>
<h4 id="anaconda国内镜像配置">Anaconda国内镜像配置</h4>
<pre><code class="language-bash">$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
$ conda config --set show_channel_urls yes
</code></pre>
<h4 id="创建虚拟环境">创建虚拟环境</h4>
<p>假设当前需要创建一个 <code>tensorflow-gpu 1.0</code> 的环境，可以按照如下的步骤操作：</p>
<pre><code class="language-bash">$ conda create -n tf1-gpu python=3.6
</code></pre>
<p><strong>注意</strong>: <code>tensorflow 1.x</code>版本仅支持到<code>python3.6</code> 输入这一条命令以后，<code>anaconda</code>就会自动的配置一个<code>python3.6</code>版本的基础环境。之后需要进入到<code>tf1-gpu</code>中，去配置相应的其他环境：</p>
<pre><code class="language-bash">$ conda activate tf1-gpu 
</code></pre>
<p>然后就在新的环境下，配置tensorflow的环境依赖。</p>
<pre><code class="language-bash">$ conda install tensorflow-gpu=1.0
</code></pre>
<p>至此一个虚拟环境就创建出来了，后面就可以在这个新的环境中愉快地玩耍了。</p>
<p>不过除此之外，还有一些其他常用的指令</p>
<pre><code class="language-bash">conda remove -n [env-name] --all  #删除某一个环境
conda env list  #查看所创建的环境列表 
</code></pre>
<h4 id="导出环境配置导入环境配置">导出环境配置/导入环境配置</h4>
<pre><code class="language-bash">conda env export &gt; environment.yaml #环境配置导出
conda env create -f environment.yaml #环境配置导入
</code></pre>
<p><em>Note: End of the copy</em></p>
<ul>
<li>清除<code>conda</code>缓存: <code>conda clean --all </code></li>
<li><code>mamba</code>：为了不被单线程的<code>conda install</code>指令慢的气死，可以考虑安装<code>mamba</code>，多线程版<code>conda</code>包（<code>conda install mamba -n base -c conda-forge</code>），之后将管理指令中的<code>conda</code>替换为<code>mamba</code></li>
</ul>
<h3 id="pytorch">PyTorch</h3>
<h4 id="install">Install</h4>
<p><a href="https://pytorch.org/get-started/previous-versions/">https://pytorch.org/get-started/previous-versions/</a></p>
<p>注意<code>pip</code>安装的<code>.whl</code>对应的<code>cu</code>（<code>cuda</code>）版本或<code>conda</code>安装的<code>cudatoolkit</code>版本，一般来说，不保证<code>pytorch</code>库能兼容比其要求低的<code>cuda</code>版本的环境</p>
<h4 id="cuda-device-dataparallel">cuda device &amp; DataParallel</h4>
<pre><code class="language-python">print(&quot;torch.__version__: &quot;, torch.__version__)
print(&quot;torch.cuda.is_available(): &quot;, torch.cuda.is_available())
print(&quot;torch.version.cuda: &quot;, torch.version.cuda)
print(&quot;cuda devices: &quot;, [torch.cuda.get_device_properties(i) for i in range(torch.cuda.device_count())])
# 检查运行时cuda版本，cuda是否可用，GPU信息
########### 
# jupyter notebook @ jack
# torch.__version__:  1.12.1
# torch.cuda.is_available():  True
# torch.version.cuda:  10.2
# cuda devices:  [_CudaDeviceProperties(name='GeForce GTX 1080 Ti', major=6, minor=1, total_memory=11178MB, multi_processor_count=28), _CudaDeviceProperties(name='GeForce GTX 1080 Ti', major=6, minor=1, total_memory=11176MB, multi_processor_count=28)]
device = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;) 
model = MyNetwork()
model = nn.DataParallel(model).to(device)
# 使用所有GPU
model = nn.DataParallel(model, device_ids=[0, 2]).to(device)
# 指定第0，2号GPU
#or
import os 
os.environ['CUDA_VISIBLE_DEVICES'] = '0,2'
model = nn.DataParallel(model).to(device)
#or
CUDA_VISIBLE_DEVICES=0,2 python3 train.py
</code></pre>
<h3 id="remote-jupyter-notebook">remote Jupyter NoteBook</h3>
<p><code>jupyter</code>框架对应的<code>.ipynb</code>（<code>jupyter notebook</code>）是可以分体运行+输出存储的<code>python</code>脚本</p>
<p><code>jupyter</code>的优点是，<code>matplotlib</code>绘图可以内嵌在结果中，代码可以方便地按<code>cell</code>分体运行，适合用来学习<code>python</code>库（不少教程是<code>.ipynb</code>的），或者看画图效果</p>
<p>以实验室服务器<code>Anaconda</code>多<code>Python</code>环境下配置<code>jupyter</code>，并使用<code>vscode</code>/浏览器远程访问<code>jupyter</code>服务为例</p>
<h4 id="jupyter-kernel">Jupyter Kernel</h4>
<p>注意，一个虚拟<code>Python</code>环境对应于一个<code>Jupyter Kernel</code></p>
<p>首先要把<code>Anaconda</code>中的虚拟<code>Python</code>环境注册到<code>Jupyter Kernel</code>中，所用工具为<code>ipykernel</code>库</p>
<p>在默认的<strong>base</strong>环境下：</p>
<pre><code class="language-bash">conda install jupyter ipykernel
</code></pre>
<p>在想要注册的环境下，例如一个<code>conda</code>中名为<code>cuda11.4</code>的环境：</p>
<pre><code class="language-bash">conda activate cuda11.4
conda install ipykernel
python -m ipykernel install --user  --name cuda11.4 --display-name &quot;cuda11.4-for-learning-pytorch&quot;
</code></pre>
<p><strong>注意：</strong><code>--name</code>参数为<code>jupyter kernelspec list</code>所列<code>kernel</code>之名，<code>--display-name</code>为<code>jupyter notebook</code>的<code>web</code>界面中<code>select kernel</code>时所列<code>kernel</code>之名</p>
<p>回到默认的<strong>base</strong>环境下（也就是使用<code>base</code>环境管理<code>Jupyter</code>，因为你不会想，也无法在<code>conda</code>里删除<code>base</code>环境）：</p>
<pre><code class="language-bash">conda activate base
</code></pre>
<h4 id="远程访问jupyter">远程访问jupyter</h4>
<p>在服务器上，利用之前讲过的<code>tmux</code>，在它里面挂一个以无<code>web</code>界面的方式启动<code>jupyter</code>的服务</p>
<pre><code class="language-bash">tmux
tmux rename jupyter_server
conda activate base
jupyter notebook --no-browser --port=&lt;server_port&gt;
#例 jupyter notebook --no-browser --port=8889
</code></pre>
<p>在<strong>个人计算机上</strong>用ssh代理绕一下服务器防火墙:-/</p>
<pre><code class="language-bash">ssh -N -f -L localhost:&lt;local_port&gt;:localhost:&lt;server_port&gt; &lt;user&gt;@&lt;server_addr&gt;
#例 ssh -N -f -L localhost:8002:localhost:8889 zhaozixuan@jack.buaadml.info
</code></pre>
<p>此时访问<code>http://localhost:&lt;local_port&gt;</code>（例<code>http://localhost:8002</code>）（带上<code>?toekn=&lt;token&gt;</code>，如果配置了的话）进入<code>jupyter</code>，注意，以上指令创建的<code>ssh</code>进程在后台运行，需要时请<code>ps -ef|grep ssh</code>找到对应进程<code>kill</code>之</p>
<figure data-type="image" tabindex="8"><img src="https://raw.githubusercontent.com/zixfy/imageshack2023/main/img/20230610222409.png" alt="" loading="lazy"></figure>
<h4 id="连接vscode">连接vscode</h4>
<ul>
<li><code>vscode</code>安装MircoSoft官方的<code>jupyter</code>插件</li>
<li><code>.ipynb</code>文件下点击右上角的<code>Select Kernel</code>，将唤起<code>vscode</code>的全局命令行</li>
<li>选择<code>Existing Jupyter Server -&gt; Enter the URL of the running Jupyter server</code>，键入代理到本地的<code>jupyter</code>地址，键入密码（如果设置了的话）和服务器配置名，选择<code>Kernel</code></li>
</ul>
<figure data-type="image" tabindex="9"><img src="https://raw.githubusercontent.com/zixfy/imageshack2023/main/img/20230610222428.png" alt="" loading="lazy"></figure>
<h4 id="显存释放">显存释放</h4>
<ul>
<li>
<p><code>cell</code>运行完后，<code>jupyter</code>不会主动结束其<code>python</code>进程，解释器的变量会驻存在内存/显存中，如果不再需要运行<code>cell</code>得到新结果，请及时在结束计算后手动<code>shutdown</code>内核或关闭<code>running</code>的<code>notebook</code></p>
<ul>
<li>或者在你最后想运行的<code>cell</code>末尾追加<code>quit(0)</code>，可以直接自动把内核挂掉</li>
</ul>
</li>
</ul>
<h3 id="jetbrains-pycharm推荐">Jetbrains Pycharm（推荐）</h3>
<h4 id="教育认证">教育认证</h4>
<p><a href="https://www.jetbrains.com/zh-cn/community/education/#students">link</a></p>
<p>建议使用北航邮箱激活Jetbrains教育认证，每次激活延期一年所有Jetbrains <code>Professional IDE</code>的使用权</p>
<figure data-type="image" tabindex="10"><img src="https://raw.githubusercontent.com/zixfy/imageshack2023/main/img/20230610220848.png" alt="" loading="lazy"></figure>
<p>相比于<code>vscode</code>, <code>pycharm IDE</code>搭建环境比较方便，不需要多少额外插件，集成了<code>ssh-interpreter</code>,<code>SFTP</code>,对<code>conda</code>,<code>venv</code>的友好支持等。为了提高工作效率，可以在本地<code>pycharm</code>编辑源码，利用服务器的<code>python</code>解释器对代码解释与运行程序，使用<code>SFTP</code>工具自动同步远程/本地</p>
<h4 id="以配置kevin的远程conda环境为例">以配置kevin的远程conda环境为例</h4>
<ul>
<li><code>Setting -&gt; Project -&gt; Add Interpreter -&gt; On SSH...</code></li>
<li>填写地址<code>kevin.buaadml.info</code>与<code>ldap</code>用户名，确保当前设备可以<code>ssh</code>免密</li>
<li>连接到服务器，<code>IDE</code>显示探查界面即连接</li>
</ul>
<figure data-type="image" tabindex="11"><img src="https://raw.githubusercontent.com/zixfy/imageshack2023/main/img/20230610220856.png" alt="" loading="lazy"></figure>
<ul>
<li>选择<code>System Interpreter</code>，服务器上在相应<code>conda</code>环境下<code>which python</code>，将打印路径粘贴到配置，<code>Sync folders</code>选项将新建一个<code>SFTP</code>配置</li>
</ul>
<figure data-type="image" tabindex="12"><img src="https://raw.githubusercontent.com/zixfy/imageshack2023/main/img/20230610222457.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p><code>Menu -&gt; Tools -&gt; Depolyment -&gt; Configuration </code>修改<code>SFTP</code>配置，解释器与<code>SFTP</code>是独立的，可以将<code>Sync folders</code>生成的删除之，使用与<code>gaia</code>的文件同步即可。</p>
</li>
<li>
<p>勾选<code>Menu -&gt; Tools -&gt; Depolyment -&gt; Automatic Upload</code>可启用保存时上传当前文件</p>
</li>
</ul>
<p>btw, 喜欢<code>vscode UI</code>的可以安装<code>2023.1</code>后版本的<code>Pycharm</code>，新<code>UI</code>更现代，更接近<code>vscode</code>的简洁风格</p>
<figure data-type="image" tabindex="13"><img src="https://raw.githubusercontent.com/zixfy/imageshack2023/main/img/20230610222533.png" alt="" loading="lazy"></figure>
<h4 id="remote-clion-idea">remote CLion, Idea...</h4>
<p><code>JetBrains</code>系<code>IDE</code>远程环境配置 大差不差</p>
<p>btw,远程协作方面推荐<code>JetBrains</code>的原生插件<code>Code With Me</code>:<a href="https://www.jetbrains.com/code-with-me/">link</a></p>
<h3 id="python">Python</h3>
<h4 id="三方库">三方库</h4>
<p><a href="https://anaconda.org/">https://anaconda.org/</a><br>
<a href="https://pypi.org/">https://pypi.org/</a></p>
<h4 id="python-进阶">Python 进阶</h4>
<p><a href="https://book.douban.com/subject/27028517/">Fluent Python</a>, <a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/chapters/p09_meta_programming.html">Python Cookbook</a>, <a href="https://book.douban.com/subject/35334595/">Effective Python</a></p>
<p>掌握一门脚本语言吧，如<code>Python</code>/<code>Linux Shell</code></p>
<h3 id="docker">Docker</h3>
<p><a href="https://docs.docker.com/get-started/">Docker Docs</a>,<a href="https://book.douban.com/subject/30486354/">《深入浅出Docker》</a>, <a href="https://kubernetes.io/zh-cn/docs/home/">K8s Doc</a></p>
<h3 id="redis">Redis</h3>
<h3 id="elasticsearch">ElasticSearch</h3>
<p><em>Acknowledgement: This section was originally created by <a href="https://github.com/zhangguiwei610">zhangguiwei</a></em></p>
<h3 id="network-tools">Network Tools</h3>
<h4 id="校园网登陆脚本">校园网登陆脚本</h4>
<pre><code class="language-bash">cd /home/dml_401/Login_Net
python Login.py#查看用法
</code></pre>
<h4 id="postman">postman</h4>
<p>一个跨平台，并支持在线使用的<code>HTTP RESTful API</code>调试工具，显然从功能性与易用性上看，是比<code>curl</code>命令好用很多很多的</p>
<p><a href="https://web.postman.co/">link</a></p>
<figure data-type="image" tabindex="14"><img src="https://raw.githubusercontent.com/zixfy/imageshack2023/main/img/20230610222552.png" alt="" loading="lazy"></figure>
<p>注意，当请求地址是一个内网地址时，无法在线通过<code>postman</code>连接，根据<code>postman</code>报错指引<code>Use Postman's Desktop Agent</code>本地安装一个<code>postman agent</code>程序，启动之，就能继续在线调试内网上的接口</p>
<h4 id="ncnetstat">nc/netstat</h4>
<p>均为传输层的<code>Linux</code>工具命令，<code>nc</code>用于发起<code>TCP/UDP</code>连接；<code>netstat</code>用于探查端口，如<code>netstat -ntlp</code>查看所有<code>TCP Socket</code>，<code>lsof -i:&lt;port_num&gt;</code>查看监听具名端口的进程</p>
<h4 id="wiresharktcpdump">wireshark/tcpdump</h4>
<p>链路层以上抓包工具，<code>tcpdump</code>命令参考<a href="https://man7.org/linux/man-pages/man1/tcpdump.1.html">link</a></p>
<p><code>WireShark</code>是一个跨平台的抓包软件，优点在于开源、支持协议多、<code>GUI</code>友好</p>
<h3 id="domain-name-cloud-server">Domain Name &amp; Cloud Server</h3>
<h4 id="云服务器">云服务器</h4>
<p>可以是获得公网<code>IP</code>的一种方式</p>
<p>国内厂商: <a href="https://developer.aliyun.com/plan/student">阿里</a>，<a href="https://cloud.tencent.com/act/campus">腾讯</a>， <a href="https://www.huaweicloud.com/product/hecs.html">华为</a>,  <a href="https://cloud.baidu.com/campaign/PromotionActivity/index.html">百度</a> 等，</p>
<p>以上厂商以学生认证+新用户购买的方式，基本可以以一百块左右买到一年的云服务器</p>
<p>通常云服务器控制台会有安全组设置，也就是厂商层面的防火墙，构建应用时注意放行相应端口</p>
<h4 id="域名">域名</h4>
<p>1.厂商：国内阿里云、腾讯云等，国外<code>GoDaddy</code>/<code>siteground</code>等，注意，在国内厂商购买的域名，或是<code>.cn</code>等后缀的域名，需要根据购买后厂商提示在工信部网站进行备案（同时严格遵守我国网信法），否则会被<code>DNS</code>服务器拒绝域名解析</p>
<p>2.<code>DNS</code>：通常来讲，一个域名往往可以通过<code>DNS</code>映射到一个<code>IP</code>地址（<code>A</code>）或另一个域名（<code>CNAME</code>），但不与端口绑定，为实现一级域名或二级域名到具体端口的路由。可以使用<code>nginx</code>的反向代理或<code>docker virtual host</code>等技术</p>
<h3 id="github">GitHub</h3>
<h4 id="pull-request">Pull Request</h4>
<ul>
<li><code>GitHub</code>网页上<code>fork</code>原始仓库</li>
<li>以<code>ssh</code>协议<code>clone</code>自己的<code>fork</code>仓到本地（<code>GitHub</code>官方已禁用用户密码管理仓库，不使用<code>ssh</code>需要使用<code>GitHub token</code>，你不会喜欢麻烦的<code>Github token</code>的）</li>
<li><code>commit</code></li>
</ul>
<pre><code class="language-bash">git checkout -b any_branch_name
git add /path/to/upload/files
git status #检查git暂存区
git commit -m “更新说明”
git push origin any_branch_name
</code></pre>
<ul>
<li>回到<code>GitHub</code>网页<code>fork</code>仓，会提示<code>compare &amp; pull request</code>，直接在网页端按提示操作</li>
<li><code>PR</code>被批准通过后，原仓库可能会额外产生一次<code>merge commit</code>，在自己<code>fork</code>仓库的<code>github</code>界面，点开之前<code>push</code>的<code>branch</code>的网页界面,有<code>sync fork</code>选项快速同步合并更新后的原始仓库</li>
</ul>
<h4 id="github-pages">Github Pages</h4>
<p><code>Github Pages</code>（仓库<code>Settings -&gt; Code and automation -&gt; Pages</code>）可以由<code>github</code>托管一个静态网站，所谓静态就是说没有后端，没有数据库，只有一坨<code>HTML/CSS/JS</code>，一般来说<code>Github Pages</code>上的大部分内容是我们写的<code>markdown</code>渲染出的<code>HTML</code>，一般通过<code>Pages branch</code>/<code>Github Actions</code>在<code>commit</code>时构建网站</p>
<figure data-type="image" tabindex="15"><img src="https://raw.githubusercontent.com/zixfy/imageshack2023/main/img/20230610222620.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>jekyll</p>
<p><a href="https://docs.github.com/zh/pages/setting-up-a-github-pages-site-with-jekyll/about-github-pages-and-jekyll">jekyll</a>是<code>github</code>官方原生支持的静态建站框架，需要<code>Ruby</code>环境，不会玩，欢迎补充</p>
</li>
<li>
<p>Gridea<br>
<code>Gridea</code>是相当简单的<code>Github Pages</code>静态建站工具：<a href="https://github.com/getgridea/gridea">link</a></p>
</li>
</ul>
<p>配置好<code>github token</code>（注意<code>token</code>需要对仓库操作放权）与仓库地址，写好<code>markdown</code>一键同步即可，<code>Gridea</code>主题:<a href="https://github.com/topics/gridea-theme">link</a></p>
<p>注意，使用<code>Gridea</code>将放弃<code>git</code>的版本控制功能，因为<code>Gridea</code>的推送方式为<code>force reset branch</code>再<code>commit</code></p>
<ul>
<li>
<p>图床与防盗链</p>
<p>为静态网站准备一个图床，因为：1.减小<code>Github Pages</code>大小 2.如果把图片存储在<code>zhihu</code>或<code>cnblogs</code>这些启用防盗链的网站上，那么在这些站点之外的网站页面上链接到这些图像，那么会被拒绝加载（<code>403</code>）</p>
<p>可以使用非常简单易用的<a href="https://picgo.github.io/PicGo-Doc/zh/">PicGo</a>，搭建<code>Github</code>图床等图床</p>
</li>
<li>
<p>Severless</p>
<p>静态网站不能利用数据库，因此可以使用<code>Serverless </code>的服务在云上存储动态数据，如使用非常简单的<code>valine</code>（<a href="https://valine.js.org/quickstart.html">link</a>）接入评论功能</p>
<ul>
<li>
<p>搭建非静态网站</p>
<p>可以在自己的服务器上建站，摆脱静态网站之限制，可以考虑<code>hexo</code>, <code>Hugo</code>, <code>Wordpress</code>等框架</p>
</li>
</ul>
</li>
</ul>
<h4 id="github-action">Github Action</h4>
<h3 id="nat-traversal">NAT traversal</h3>
<p><strong>！！！以下软件请仅用于个人计算机，且自行承担一切网安风险（如校园网环境下隧道有可能被北航墙掉）！！！</strong></p>
<h4 id="反向代理">反向代理</h4>
<figure data-type="image" tabindex="16"><img src="https://raw.githubusercontent.com/zixfy/imageshack2023/main/img/20230610220952.png" alt="" loading="lazy"></figure>
<p>以上是正向代理与反向代理两种模式的示意图，可以看到正向代理下，被代理的是请求机器，所以代理客户端在请求机器，代理服务端跑在代理服务器上。这样，指明访问地址时，代理软件会帮我们通过代理服务器做中转，从而绕过防火墙等网络策略访问到目标服务器。</p>
<figure data-type="image" tabindex="17"><img src="https://raw.githubusercontent.com/zixfy/imageshack2023/main/img/20230610221007.png" alt="" loading="lazy"></figure>
<p>而在反向代理下，被代理的是目标服务器，请求机器上，代理服务器就等价于目标服务器。请求机器不必给代理服务器提供目标服务器的网址等路由信息，通常它也无法知晓。这时，代理软件需要在 代理服务器（中转服务器）上跑服务端，在目标服务器上跑客户端。反向代理的场景：1.负载均衡，请求转发到节点，如nginx 2.内网穿透：设想我想把个人计算机搭建为服务器，但没有公网IP，只有局域网IP，那么可以把我的计算机交给代理服务器代理，利用它的公网IP将个人计算机暴露在互联网上。没有公网IP时，自然的解决方案就可以是内网穿透，也就是打洞。</p>
<h4 id="frp">frp</h4>
<p><code>frp</code>：开源软件，使用需要一台中转服务器</p>
<p>以<code>frp</code>反向代理实现内网穿透<code>Secure Shell</code>服务为例</p>
<p><code>Github Release</code>: <a href="https://github.com/fatedier/frp/releases">link</a> ,下载相应<code>os</code>与指令集架构的压缩包，解压之，目录下<code>frpc</code>/<code>frps</code>是客户端，<code>frpc.ini</code>/<code>frps.ini</code>为相应配置文件</p>
<p>在内网机器上配置<code>frpc.ini</code></p>
<pre><code class="language-bash">[common]
server_addr = &lt;remote_addr&gt; #远程端frps端服务器的公网地址
server_port = 7001 #远程服务端frps占用端口
token = &lt;use_a_random_generator_to_get_a_more_complex_token&gt; 
# 客户端服务端对称认证密钥，可256位
use_encryption = true
use_compression = true
#报文对称加密与压缩
#tls_enable = true
#tls_trusted_ca_file = /to/ca/path/ca.crt
#TLS加密，https://gofrp.org/docs/features/common/network/network-tls/
#log_level = debug
log_file = /var/log/frpc.log
#志记
[ssh] #配置名字
type = tcp #指定协议
local_ip = 127.0.0.1 # 穿透的地址，本机可ssh登录的地址即可，可以是同局域网另一机器，可改
local_port = 22 # ssh监听端口
remote_port = 8022 # 代理到frps服务器的端口号，可改
</code></pre>
<p>在中转机器上配置<code>frps.ini</code>，确保中转机器可被请求机器与内网机器访问</p>
<pre><code class="language-bash">[common]
bind_port = 7001 #frps占用端口
token = &lt;use_a_random_generator_to_get_a_more_complex_token&gt; 
# 客户端服务端对称认证密钥，可256位
use_encryption = true
use_compression = true
#报文对称加密与压缩
#vhost_http_port = 80 
#穿透http服务所用端口，https://gofrp.org/docs/examples/vhost-http/
#tls_enable = true
#tls_cert_file = /root/frp/server.crt
#tls_key_file = /root/frp/server.key
#TLS加密，https://gofrp.org/docs/features/common/network/network-tls/
#log_level = debug
log_file = /var/log/frps.log
#志记
</code></pre>
<p>以<code>/path/to/frpc -c /path/to/frpc.ini</code>启动内网机器的客户端，<code>/path/to/frps -c /path/to/frps.ini</code>启动中转服务器的服务端，此时在请求机器上<code>ssh &lt;user&gt;@&lt;remote_addr&gt; -p 8022</code>等价于<code>ssh</code>登录内网机器（<code>local_ip:local_port</code>）</p>
<p><strong>注意</strong>，我们需要保证<code>frp</code>，特别是<code>frpc</code>的稳定性，因为<code>frpc</code>中断后必须要有主动重连<code>frps</code>的能力，因为<code>frps</code>无法寻址到使用<code>NAT</code>的内网机器</p>
<p>所以使用上文说到的<code>systemd</code>为例，为<code>frpc</code>/<code>frps</code>注册守护进程<code>vi /etc/systemd/system/frps.service</code></p>
<pre><code class="language-bash">[Unit]
Description=frps(nei_wang_chuan_tou)
After=network.target
Wants=network.target

[Service]
Restart=on-failure
RestartSec=5
ExecStart=/root/frp/frps -c /root/frp/frps.ini

[Install]
WantedBy=multi-user.target                     
</code></pre>
<p>其中<code>ExecStart</code>为启动命令（<code>systemctl start</code>），当进程异常终止时等待<code>RestartSec=5</code>秒重新启动</p>
<pre><code class="language-bash">systemctl daemon-reload # 刷新配置
systemctl start frps.service # 启动服务
systemctl enable frps.service # 开机自启
</code></pre>
<h4 id="autossh内网穿透">autossh内网穿透</h4>
<p><a href="https://liyirui-git.github.io/tech/%E6%8A%98%E8%85%BE/autossh%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F.html">liyirui.github.io</a></p>
<h4 id="闭源软件">闭源软件</h4>
<ul>
<li>向日葵/ToDesk：主要功能是远程桌面控制</li>
<li>花生壳：免费版有隧道数量限制，且已经不支持穿透<code>http</code>协议，支持<code>tcp/udp/https</code>（2023.3）</li>
<li><code>ngrok</code>：2.x版本已闭源</li>
<li><code>cpolar</code>: 同样只需要部署客户端，服务端由厂商服务器支持,<a href="https://www.cpolar.com/"> https://www.cpolar.com/</a></li>
</ul>
<p>以<code>cpolar</code>实现通过<code>anna</code>（windows）内网穿透<code>ssh</code>与<code>http</code>服务为例，配置<code>C:\Users\Administrator\.cpolar\cpolar.yml</code></p>
<pre><code class="language-yaml">authtoken: &lt;cpolar_auth&gt;
tunnels:
  ssh:
    proto: tcp
    addr: &quot;10.*.*.*:22&quot;
    remote_addr: 8.tcp.cpolar.top:1****
  vue:
    proto: http
    addr: &quot;10.*.*.*:*****&quot;
    subdomain: vssvue
  ssh2:
    proto: tcp
    addr: &quot;10.*.*.*:22&quot;
    remote_addr: 2.tcp.cpolar.top:****
</code></pre>
<p><strong>注意</strong>，其中被穿透的机器为<code>10.*.*.*</code>，而不是<code>anna</code>，<code>anna</code>只是一个二级跳板</p>
<p><code>&lt;cpolar_auth&gt;</code>为<code>cpolar</code>账户的密钥, <code>remote_addr</code>与<code>subdomain</code>字段为保留二级域名/端口，需要在<code>cpolar</code>官网使用自己的账号购买</p>
<p>启动<code>cpolar</code></p>
<pre><code class="language-powershell">#cmd
D:\
cd cpolar
.\cpolar.exe list
.\cpolar.exe start vue
.\cpolar.exe start ssh
.\cpolar.exe start ssh2
</code></pre>
<p>以我当前的配置文件与<code>cpolar</code>账号设置,使用<code>ssh root@***.cpolar.*** -p 1****</code>登录内网机器，通过<code>http://*****.cpolar.***</code>访问<code>web</code>应用</p>
<p>最后使用批处理脚本自动重启<code>cpolar</code>客户端</p>
<pre><code class="language-powershell">#ssh.bat
:start
.\cpolar.exe start ssh
timeout /t 60 /nobreak &gt; nul
goto start
</code></pre>
<p><code>.\ssh.bat</code>运行之</p>
<h3 id="ldap">LDAP</h3>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-5616441"><label class="task-list-item-label" for="task-item-5616441"> TODO</label></li>
</ul>
<h3 id="plugin-a-new-machine">Plugin a new machine</h3>
<ul>
<li>ubuntu启动盘制作：略</li>
<li>装机脚本</li>
<li>运行脚本后的LDAP配置</li>
<li>安装显驱：使用nvidia runfile</li>
<li>启动GPU监控脚本</li>
</ul>
<h3 id="latexmarkdown">LaTeX/Markdown</h3>
<ul>
<li>toolchain: 1. <code>Overleaf</code>, 在线就是方便 2.可以装一个跨平台<code>LaTeX</code>编译器，如<code>TeXLive</code>, <code>MikTex</code>，然后使用相关<code>IDE</code>，如<code>TeXstudio</code>, <code>VSCode</code>等</li>
<li>LaTeX插入伪代码：<code>\usepackage{algorithmicx}</code> or <code>\usepackage{algpseudocode}</code> or <code>\usepackage{algpseudocodex}</code></li>
<li>LaTex做ppt: <code>Beamer</code></li>
<li>markdown编辑器：<code>Typora</code>,所见即所得</li>
<li>markdown最终会渲染为<code>HTML</code>，所以<code>markdown</code>是原生可内嵌<code>html</code>块的</li>
</ul>
<h3 id="endnote">EndNote</h3>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox" id="task-item-4906122"><label class="task-list-item-label" for="task-item-4906122"> TODO</label></li>
</ul>
<h3 id="util">util</h3>
<ul>
<li><a href="https://github.com/BHOSC/BUAAthesis">北航毕设LaTeX模板</a></li>
<li><a href="https://github.com/TheBloodthirster/BUAA_Course_Sharing">北航课程资料仓</a></li>
<li><a href="https://www.cnblogs.com/khunkin/tag/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">北航计算机网络实验博客</a></li>
<li><a href="https://bhpan.buaa.edu.cn:443/link/2206208E3EA8D07A4C70719806DE989E">一个北航ppt白板模板</a></li>
<li><a href="https://bhpan.buaa.edu.cn:443/link/8118A1CB56FD3022C8ADB123C6D0205F">北航《大数据处理与机器学习算法实训》23春作业与代码</a></li>
<li><a href="https://bhpan.buaa.edu.cn:443/link/6C0C4889FAFCC1D44F0B16A30AEC8A51">北航《算法分析与设计》22秋作业</a>， <a href="https://bhpan.buaa.edu.cn:443/link/6F788707FB9D255AD75DD694F43FB828">《算法分析与设计》20春作业</a></li>
<li><a href="http://cs231n.stanford.edu/">Stanford University CS231n</a></li>
<li><a href="https://github.com/zixfy/cs231n_assignments_2021">zixfy's cs231n_assignments_2021</a></li>
<li><a href="https://godbolt.org/">Compiler Exploer</a></li>
<li><a href="https://www.overleaf.com/">Overleaf 编辑器</a></li>
<li><a href="https://www.cmor-faculty.rice.edu/~heinken/latex/symbols.pdf">LaTeX Symbols</a></li>
<li><a href="https://www.dokuwiki.org/zh:wiki:syntax">DokuWiki tutorials</a></li>
<li><a href="https://paperswithcode.com/">paperswithcode</a></li>
</ul>
<p>以上，初稿于2023.6</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++手写优先队列]]></title>
        <id>http://zixfy.github.io/post/c-shi-xian-er-cha-dui/</id>
        <link href="http://zixfy.github.io/post/c-shi-xian-er-cha-dui/">
        </link>
        <updated>2023-10-01T10:32:30.000Z</updated>
        <content type="html"><![CDATA[<p>原文：<a href="https://zhuanlan.zhihu.com/p/659218897">zhihu</a></p>
<p><code>c++</code>手撕一个简化版的优先队列..</p>
<p>优先队列用于维护一组数据及其优先级，通常支持<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>查找优先级最大（小）的队首元素，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi>N</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">log(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>入队元素与弹出队首元素</p>
<p>在<code>c#</code>泛型优先队列中，优先值是显式的（<code>PriorityQueue&lt;TElement,TPriority&gt;</code>），也就是同时存储元素和优先值，且维护队首元素优先值最小</p>
<p>而在<code>C++ STL</code>中<code>std::priority_queue&lt;T&gt;</code>维护队首元素优先值最大，且优先值是隐式的，较小的元素有较小的优先值，默认的小于号比较器是<code>std::less&lt;&gt;</code></p>
<p>也就是说<code>std::priority_queue&lt;int, vector&lt;int&gt;, std::greater&lt;&gt;&gt; </code>维护最小值，<code>std::priority_queue&lt;int, vector&lt;int&gt;, std::less&lt;&gt;&gt; </code>维护最大值</p>
<p>所以如果实际中优先值与元素类型没有关系，我们可以把存储类型更改为<code>std::pair&lt;TPriority, T&gt;</code>，或者新建类型绑定优先值与元素</p>
<p>我们可以利用最大二叉堆实现一个类似的优先队列</p>
<p>最大二叉堆是这样一颗完全二叉树（所有层，除了最后一层都一定是满的，且节点靠左排列）</p>
<p>且二叉堆中任意节点满足<strong>性质</strong>，节点大于所有其子节点</p>
<p>由于是完全二叉树，可以直接用数组存储树结构，令根节点位于下标<code>0</code>，则节点<code>x</code>的父节点为<code>(x - 1) / 2 </code>，左右节点为<code>2 * x + 1</code>, <code>2 * x + 2</code></p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/zixfy/imageshack2023/main/img/20231001183409.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://raw.githubusercontent.com/zixfy/imageshack2023/main/img/20231001183425.png" alt="" loading="lazy"></figure>
<p>二叉堆的核心在于插入与删除，因为最大元素已经在数据开头了</p>
<p>先声明优先队列的主要成员</p>
<pre><code class="language-c++">template&lt;typename T, typename Compare = std::less&lt;T&gt;&gt;
class PriorityQueue {
private:
    using uz = std::size_t;
    std::vector&lt;T&gt; _vec;
    Compare _cmp;
public:
    explicit PriorityQueue(Compare cmp = {}) : _vec{}, _cmp{cmp} {}
    template&lt;typename Iterator&gt;
    PriorityQueue(Iterator begin, Iterator end, Compare cmp = {}): _vec(begin, end),
                                                                   _cmp{cmp} { _maintain_from_chaos(); }

    inline auto size() { return _vec.size(); }
    inline auto empty() { return _vec.empty(); }
    inline auto clear() { _vec.clear(); }

    T const &amp;peek();
    inline T const *try_peek();

    template&lt;typename ForwardAsT = T&gt; void push(ForwardAsT &amp;&amp;value);
    template&lt;typename ...Args&gt; void emplace(Args ...args);

    T pop();
    inline std::optional&lt;T&gt; try_pop();

private:
    inline auto _father_of(uz x) {return (x - 1) &gt;&gt; 1;}
    inline auto _left_of(uz x) {return (x &lt;&lt; 1) | 1;}

    void _maintain_up(uz current);
    void _maintain_down(uz current);
    inline void _maintain_from_chaos();
};
</code></pre>
<p>其中<code>uz</code>为<code>std::size_t</code>，<code>_cmp</code>是小于号(<code>&lt;</code>)，<code>_vec</code>是最大堆</p>
<p>因为队列可能为空，为查询最大元素与出队最大元素也提供了安全的<code>try_peek()</code>, <code>try_pop</code></p>
<p>入队元素的函数为<code>push</code>与<code>emplace</code></p>
<p><code>push</code>会从实参拷贝(移动)构造新元素<code>T</code>，而</p>
<pre><code class="language-c++">template&lt;typename ...Args&gt; void emplace(Args ...args);
</code></pre>
<p>的形参是<code>T</code>构造函数的参数，我们将在这个函数中利用<code>std::vector::emplace_back</code>原地构造对象，有些情况下可以节省一次拷贝或移动</p>
<p>这里</p>
<pre><code class="language-c++">template&lt;typename ForwardAsT = T&gt; void push(ForwardAsT &amp;&amp;value);
</code></pre>
<p>的万能引用写成<code>ForwardAsT &amp;&amp;</code>而不是<code>T&amp;&amp;</code>的原因是在<code>PriorityQueue&lt;T, Compare&gt;</code>类内部，<code>T</code>已经被替换成具体的元素类型了，所以<code>T&amp;&amp;</code>是右值引用，而不是万能引用</p>
<p>比如</p>
<pre><code class="language-c++">template&lt;typename T&gt; struct A { 
    void f(T&amp;&amp;) {
        cout &lt;&lt; &quot;okay for overload of lvalue reference&quot;;
    }
};
int main() { 
    int b = 2;
    A&lt;int&gt;{}.f(b);
} 
</code></pre>
<p>报错<code>error: rvalue reference to type 'int' cannot bind to lvalue of type 'int'</code>, 而以下代码可以编译</p>
<pre><code class="language-c++">template&lt;typename T&gt; struct A {
    template&lt;typename TT = T&gt;
    void f(TT&amp;&amp;) {
        cout &lt;&lt; &quot;okay for overload of lvalue reference&quot;;
    }
};
</code></pre>
<p>具体实现上，首先考虑入队，直接将新元素尾插二叉堆数组</p>
<pre><code class="language-c++">template&lt;typename ForwardAsT = T&gt;
void push(ForwardAsT &amp;&amp;value) {
    _vec.push_back(std::forward&lt;ForwardAsT&gt;(value));
    _maintain_up(_vec.size() - 1);
}
</code></pre>
<p>而新插入的节点可能破坏了父节点的性质（比新节点还小），所以写一个<code>_maintain_up(x)</code>函数用于维护<code>x</code>的父节点的性质，如果父节点比<code>x</code>小，就不断地交换二者</p>
<pre><code class="language-c++">void _maintain_up(uz current) {
    while (current != 0) {
        auto father = _father_of(current);
        if (_cmp(_vec[father], _vec[current]))
            std::swap(_vec[father], _vec[current]);
        // if father &lt; current , let current grow
        else break;
        current = father;
    }
}
</code></pre>
<p>而出队时，首先交换二叉堆数组开头元素（根节点）与末尾元素，弹出并返回末尾的最大值</p>
<pre><code class="language-c++">T pop() {
    if (empty())
        throw std::runtime_error(&quot;pop on a empty PriorityQueue&quot;);
    std::swap(_vec.front(), _vec.back());
    auto ret = std::move(_vec.back());
    _vec.pop_back();
    _maintain_down(0);
    if (_vec.size() &gt; 32 &amp;&amp; _vec.size() * 2 &lt; _vec.capacity())
        _vec.shrink_to_fit();
    return ret;
}
</code></pre>
<p>而此时根节点的性质可能被破坏，所以写一个<code>_maintain_down(x)</code>函数用于维护<code>x</code>节点的性质，如果<code>x</code>比最大的孩子小，就不断地交换二者</p>
<pre><code class="language-c++">void _maintain_down(uz current) {
    for (auto child = _left_of(current); child &lt; _vec.size(); child = _left_of(current)) {
        // while there is still any children for current node
        if (auto sibling = child + 1; sibling &lt; _vec.size() &amp;&amp; _cmp(_vec[child], _vec[sibling]))
            child = sibling;
        // select biggest child
        if (_cmp(_vec[current], _vec[child]))
            std::swap(_vec[current], _vec[child]);
        // if current  &lt; child, let child grow
        else break;
        current = child;
    }
}
</code></pre>
<p>查询最大元素</p>
<pre><code class="language-c++">T const &amp;peek() {
    if (empty())
        throw std::runtime_error(&quot;peek on a empty PriorityQueue&quot;);
    return _vec.front();
}
</code></pre>
<p>最后是构造函数，基本构造函数设计为迭代器形参</p>
<pre><code class="language-c++">template&lt;typename Iterator&gt;
PriorityQueue(Iterator begin, Iterator end, Compare cmp = {}): _vec(begin, end),
_cmp{cmp} { _maintain_from_chaos(); }
</code></pre>
<p>由于初始二叉堆是无序的，在<code>_maintain_from_chaos</code>函数中从底向上遍历二叉堆的节点，都调用一遍<code>_maintain_down</code>维护自身性质即可</p>
<pre><code class="language-c++">inline void _maintain_from_chaos() {
    for (uz i = _vec.size(); i &gt; 0;)
        _maintain_down(--i);
}
</code></pre>
<p>再完善一下构造函数，支持<code>std::initializer_list</code>与可迭代类型</p>
<pre><code class="language-c++">PriorityQueue(std::initializer_list&lt;T&gt; il, Compare cmp = {}) : PriorityQueue(il.begin(), il.end(), cmp) {}
</code></pre>
<pre><code class="language-c++">template&lt;typename Container&gt; using UniIter = std::conditional_t&lt;
            std::is_rvalue_reference_v&lt;Container&gt;,
            std::move_iterator&lt;typename std::decay_t&lt;Container&gt;::iterator&gt;,
            typename std::decay_t&lt;Container&gt;::iterator&gt;;
template&lt;typename Container&gt; explicit
PriorityQueue(Container &amp;&amp;container, Compare cmp = {}): PriorityQueue(
    UniIter&lt;decltype(container)&gt;(container.begin()), UniIter&lt;decltype(container)&gt;(container.end()), cmp) {}
</code></pre>
<p>这样就完成啦</p>
<p><code>code</code>: <a href="https://github.com/zixfy/cpp-algorithm/blob/main/data-structure/priority_queue.hpp">Github</a></p>
<p>使用例：<code>pair</code>的小根堆</p>
<pre><code class="language-c++">int main() {
    std::mt19937 rng{std::random_device{}()};
    auto q1 = PriorityQueue&lt;std::pair&lt;int, int&gt;, std::greater&lt;&gt;&gt;{{114, 514}, {1919, 810}};
    for (int i = 0; i &lt; 17; i++)
        q1.emplace(rng() % 4, rng() % 100);
    while (!q1.empty()) {
        auto [a, b] = q1.pop();
        cout &lt;&lt; &quot;(&quot; &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; b &lt;&lt; &quot;), &quot;;
    }
}
// (0, 57), (0, 89), (1, 4), (1, 29), (1, 40), (1, 42), (1, 50), (2, 3), (2, 23), (2, 57), (2, 65), (2, 75), (3, 0), (3, 26), (3, 85), (3, 86), (3, 87), (114, 514), (1919, 810), 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【c++】递归lambda式]]></title>
        <id>http://zixfy.github.io/post/c-di-gui-lambda-shi/</id>
        <link href="http://zixfy.github.io/post/c-di-gui-lambda-shi/">
        </link>
        <updated>2023-09-30T14:35:26.000Z</updated>
        <content type="html"><![CDATA[<p>原文：<a href="https://zhuanlan.zhihu.com/p/659147057">zhihu</a></p>
<p>首先，什么是<code>lambda</code>？</p>
<p>是闭包，是函数对象（重载了<code>operator()</code>的类型），是一种持有状态的函数</p>
<p>当写下</p>
<pre><code class="language-c++">auto a = 2;
auto f = [&amp;](int x) {return a * x;};
</code></pre>
<p>时，编译器会把代码翻译成大概下面这样，生成一个匿名类（<a href="https://cppinsights.io/">https://cppinsights.io/</a>翻译的结果）</p>
<pre><code class="language-c++">int a = 2;

class __lambda_6_12
{
    public: 
    inline /*constexpr */ int operator()(int x) const
    {
        return a * x;
    }

    private: 
    int &amp; a;

    public:
    __lambda_6_12(int &amp; _a)
        : a{_a}
    {}

};

__lambda_6_12 f = __lambda_6_12{a};
</code></pre>
<p><code>lambda</code>的优点在于简化了函数对象的编码，把函数对象定义在了调用处，同时减少了命名（无需类型命名，只需命名变量或无需命名），如果不打算重用函数，比如<code>std::thread</code>构造函数传入的线程运行函数，可以考虑<code>lambda</code></p>
<p>但如果<code>lambda</code>一定需要递归实现呢？</p>
<p>比如说下文中我们想实现一个递归打印数字的<code>count_down</code>函数，其中分隔符<code>sep</code>不是固定的</p>
<p>对于常规函数与函数对象（闭包），可以维护一个全局变量或成员变量<code>sep</code></p>
<pre><code class="language-c++">std::string sep = get_sep();
auto count_down(int x) -&gt; std::string  
    return x == 0 ? &quot;0&quot; : std::to_string(x) + sep + count_down(x - 1);
}
</code></pre>
<p>或者把<code>sep</code>作为一个额外形参</p>
<pre><code class="language-c++">auto count_down(int x, std::string const&amp; sep) -&gt; std::string { 
    return  x == 0 ? &quot;0&quot; : std::to_string(x) + sep + count_down(x - 1, sep);
}
</code></pre>
<p>而对于<code>lambda</code>，我们可以首先尝试一下把<code>lambda</code>式变量名按引用捕获到<code>lambda</code>函数体里面</p>
<pre><code class="language-c++">std::string sep = get_sep();
auto count_down = [&amp;](int x) -&gt; std::string { 
    return  x == 0 ? &quot;0&quot; : std::to_string(x) + sep + count_down(x - 1);
};
</code></pre>
<p><code>oops</code>.. 编译失败了，报错是</p>
<p><code>error: variable 'count_down' declared with deduced type 'auto' cannot appear in its own initializer</code></p>
<p>因为我们需要把右侧匿名的<code>lambda</code>赋值给左侧<code>auto</code>的变量<code>count_down</code>，而对于编译器，需要解析完赋值表达式的右侧才能确定<code>auto</code>对应的<code>lambda</code>类型，所以我们在函数体里使用类型未定的<code>count_down</code>自身时，很不幸，编译器拒绝了类型推导</p>
<p>所以问题在于在递归调用时需要确定<code>lambda</code>本身的类型</p>
<p>第一种解决方案，使用<code>std::function</code></p>
<pre><code class="language-c++">std::string sep{&quot;, &quot;}
std::function&lt;std::string(int)&gt; count_down = [&amp;](int x) -&gt; std::string { 
    return  x == 0 ? &quot;0&quot; : std::to_string(x) + sep + count_down(x - 1);
};
cout &lt;&lt; count_down(5);
//5, 4, 3, 2, 1, 0
</code></pre>
<p>可以编译了的原因是<code>std::function</code>对象内部存储了<code>lambda</code>可调用对象，<code>std::function</code>调用<code>operator()</code>时，会把实参完美转发到内部的可调用对象，由于指定了<code>std::function</code>的模板参数类型，我们回避了匿名类型的问题</p>
<p>然而这里有两个小问题</p>
<ol>
<li>由于<code>lambda</code>存在<code>function</code>里，递归的调用链是<code>function-&gt;lambda-&gt;function-&gt;lambda-&gt;...</code></li>
<li>函数签名重复写了两次，太丑了</li>
</ol>
<p>好在<code>C++14</code>支持了泛型<code>lambda</code>，回想下问题在于在<code>lambda</code>递归调用时需要确定本身的类型，那我们其实只给<code>lambda</code>多加一个指向自身的泛型形参就好了，实现如下</p>
<pre><code class="language-c++"> auto count_down = [impl = [&amp;](auto const &amp;self, int x) -&gt; std::string {
    return x == 0 ? &quot;0&quot; : std::to_string(x) + sep + self(self, x - 1);
}](auto &amp;&amp;...args) {
    return impl(impl, std::forward&lt;decltype(args)&gt;(args)...);
};
</code></pre>
<p>思路就是把<code>lambda</code>式存在另一个闭包里，闭包调用时，调用实际的递归函数，同时把它自身的引用作为第一个参数，这样实际上<code>lambda</code>对象只是不断递归调用自身</p>
<p>当然这么写还是麻烦，我们把生成新闭包和转发实参的部分也写成一个如下的泛型<code>lambda</code>（函数装饰器）</p>
<pre><code class="language-c++"> auto recursive_lambda = [](auto &amp;&amp;lam) {
     return [lam_impl = std::forward&lt;decltype(lam)&gt;(lam)](auto &amp;&amp;...args) {
         return lam_impl(lam_impl, std::forward&lt;decltype(args)&gt;(args)...);
     };
 };
</code></pre>
<p>这样就实现了递归<code>lambda</code>式</p>
<pre><code class="language-c++">std::string sep{&quot;...&quot;};  
auto count_down = recursive_lambda([&amp;](auto const &amp;self, int x) -&gt; std::string  { 
    return x == 0 ? &quot;0&quot; : std::to_string(x) + sep + self(self, x - 1);
});
cout &lt;&lt; count_down(5);
//10...9...8...7...6...5...4...3...2...1...0 
</code></pre>
<p>注意上述<code>recursive_lambda</code>使用时，如果返回类型不是<code>void</code>，需要在<code>lambda</code>形参之后，函数体之前使用<code>-&gt;</code>尾置返回类型</p>
]]></content>
    </entry>
</feed>